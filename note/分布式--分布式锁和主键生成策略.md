- [https://segmentfault.com/a/1190000012919740](https://segmentfault.com/a/1190000012919740)

- 随着业务越来越复杂，应用服务都会朝着分布式、集群方向部署，而分布式[CAP原则](https://link.segmentfault.com/?enc=hb0D4r5deRw5qKzWIiTnGw%3D%3D.wOBzwQeIYktdK9aavM%2FsTtWsnwC505a1U5i%2BgnxJcwdMgcXxjPu2cSjwGcmNuxrxux6mmGWj1Lym1Ta56DuMZQ%3D%3D)告诉我们，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼

  - [https://www.cnblogs.com/duanxz/p/5229352.html](https://www.cnblogs.com/duanxz/p/5229352.html)

- 分布式锁要求

  - 可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。

  - 这把锁要是一把可重入锁（避免死锁）

  - 这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）

  - 有高可用的获取锁和释放锁功能

  - 获取锁和释放锁的性能要好

- 对于分布式锁一般基于下面三种

  - 数据库实现分布式锁

  - 基于缓存实现分布式锁

  - 基于zookeeper

- 数据库实现分布式锁

  - 基于数据库表实现

    - 当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。

    - 缺点

      - 数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。

      - 没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。

      - 非阻塞的？搞一个while循环，直到insert成功再返回成功。

      - 非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。

  - 基于数据库排他锁

    - [https://blog.csdn.net/hou_ge/article/details/112754366](https://blog.csdn.net/hou_ge/article/details/112754366)

    - `select * from methodLock where method_name=xxx for update`

    - 在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁（这里再多提一句，InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给method_name添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。）。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。

    - 阻塞锁？ for update语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。

    - 锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。

- 基于redis缓存实现分布式锁 [https://segmentfault.com/a/1190000012919740](https://segmentfault.com/a/1190000012919740)

  - 锁的实现主要基于redis的SETNX命令 （set if not exist）设置成功，返回 1 。设置失败，返回 0 。释放锁，使用DEL命令将锁数据删除

  - 实现带超时时间的锁获取功能 解决锁无法释放

  - 

- 基于Zookeeper实现分布式锁

  - 大致思想即为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。

- 分布式数据库主键生成策略(*)

  - [https://www.jianshu.com/p/a0a3aa888a49](https://www.jianshu.com/p/a0a3aa888a49)

  - [https://tech.meituan.com/MT_Leaf.html](https://tech.meituan.com/MT_Leaf.html)

- 反向代理是什么？

  - 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器簇的存在.

- 负载均衡是什么？

  - 负载平衡（Load balancing）是一种计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。 使用带有负载平衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务通常是由专用软件和硬件来完成。 主要作用是将大量作业合理地分摊到多个操作单元上进行执行,用于解决互联网架构中的高并发和高可用的问题。