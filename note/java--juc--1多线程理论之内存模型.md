#### **硬件架构模型**

<img src="https://leslieyedoc.oss-cn-shanghai.aliyuncs.com/img/20250910-144855-image-20250910144852798.png" alt="image-20250910144852798" style="zoom:50%;float:left" />

- **CPU**
  - 一般在大型服务器上会配置多个CPU，每个CPU还会有多个核，这就意味着多个CPU或者多个核可以同时（并发）工作。如果使用Java 起了一个多线程的任务，很有可能每个 CPU 都会跑一个线程，那么你的任务在某一刻就是真正并发执行了。

- **CPU Register**
  - CPU Register也就是 CPU 寄存器。CPU 寄存器是 CPU 内部集成的，在寄存器上执行操作的效率要比在主存上高出几个数量级。
- **CPU Cache Memory**
  - CPU Cache Memory也就是 CPU 高速缓存，相对于寄存器来说，通常也可以成为 L2 二级缓存。相对于硬盘读取速度来说内存读取的效率非常高，但是与 CPU 还是相差数量级，所以在 CPU 和主存间引入了多级缓存，目的是为了做一下缓冲。
- **Main Memory**
  - Main Memory 就是主存，主存比 L1、L2 缓存要大很多。

#### 缓存一致性问题

> 使用高速缓存解决了 CPU 和主存速率不匹配的问题，但同时又引入另外一个新问题：缓存一致性问题。

#### 处理器优化和指令重排序

#### 并发编程的问题

- 原子性
- 可见性
- 有序性

#### java运行时内存区域与硬件内存的关系

<img src="https://leslieyedoc.oss-cn-shanghai.aliyuncs.com/img/20250910-145702-image-20250910145700095.png" alt="image-20250910145700095" style="zoom:50%;float:left" />

####  Java 线程与主内存的关系

- 所有的变量都存储在主内存（Main Memory）中。
- 每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的拷贝副本。
- 线程对变量的所有操作都必须在本地内存中进行，而不能直接读写主内存。
- 不同的线程之间无法直接访问对方本地内存中的变量。
  - <img src="https://leslieyedoc.oss-cn-shanghai.aliyuncs.com/img/20250910-145806-8209378_932a75c0-bc17-4c08-bd9f-b8dcb8467793.png" alt="img" style="zoom:50%;float:left" />

- #### 线程间通信

  - 为了更好的控制主内存和本地内存的交互，Java 内存模型定义了八种操作来实现：

    - lock：锁定。作用于主内存的变量，把一个变量标识为一条线程独占状态。

    - unlock：解锁。作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

    - read：读取。作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用

    - load：载入。作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。

    - use：使用。作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。

    - assign：赋值。作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。

    - store：存储。作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。

    - write：写入。作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。