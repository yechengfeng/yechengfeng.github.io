##### 项目介绍

> 从业务上来说，我们这个支付中台主要有**下单，支付，退款，对账，充值**还有报表等相关业务，之前我们这个平台所有材料都是免费的，这个平台2015年开始运维，用户量也达到了50多万，产品为了提升公司收益就想对部分资料进行收费，我们做支付相关业务  具体商品费用多少，哪些商品进行收费，这个是商品部门做的。----我简单说一下整个业务流程就是用户（老师或者学生或者学生家长）电脑登录奇点学院APP，后会根据自己需要的材料选择性购买，我们有一个资源中心，产品就会在这个微服务部门后台上架一些收费的资源， 比如教学资料，学习视频。考试考卷，系列课程。然后用户对应的材料进行购买，点击材料后面购买按钮后首先会在我们支付微服务创建一个商品订单，然后用户可以选择取消该订单或者去支付，点击去支付跳转公司收银台，然后用户选择支付方式，选择好支付方式后提交后会为这个商品订单创建一个支付订单，商品订单和支付订单是1对多的关系，因为用户可能选择了微信支付提交后没付款后面又选择了支付宝支付，支付成功后等渠道方回调我们这边接口后，我们在回调接口中会修改支付状态以及调用下游资源部门接口做对应的业务操作，比如 用户购买课程后就可以进行课程学习了。大致的业务流程就是这些。从技术上来说，我们项目技术架构采用的是springcloud alibaba那一套，微服务组件用到了sentinel做核心接口限流，gateway做跨域设置和用户参数封装以及接口安全性验证和断言配置，nacos做服务注册中心和配置中心，openfeign实现服务之间远程调用，对于一些不需要返回结果的业务我们也用到了mq实现微服务之间的交互，其他中间件用到了redis做缓存，mysql做数据持久化，xxl-job做定时任务。

个人职责

> 1. 对接微信和支付宝开发文档开发渠道支付、**用户主动关单、延迟关单、查询支付状态 以及支付成功后回调接口相关业务功能**。
>
> 2. 开发用户账户余额充值功能并选用最优方案开发用户余额和渠道组合支付功能。
> 3. 开发全额退款、部分退款以及组合退款优先退余额等相关逆向业务。
>
> 4. 开发支付对账功能，后期采用redis set集合+mysql实现分批对账解决redis大key和mysql连接过多问题。
>
> 5. 开发管理员退款审批功能，并采用seata at模式处理该业务中微服务调用出现的分布式事务问题。
> 6. 优化支付相关业务逻辑，抽离出具体的功能方法实现方法复用，同时使用设计模式优化渠道支付逻辑，避免引入新渠道出现过多的if else判断。
>
> 7. 对开发中遇到的各种问题进行定位和解决(用户重复支付，重复下单，回调接口重复通知，第三方接口传参异常，长款和短款问题等问题)并通过单元测试对测试用例进 行自测。
>
>  **优化:**
>
> 1. 优化后期报表数据接口响应时间慢问题。
>
> 2. 优化支付对账逻辑，提升对账速度。
>
> 3. 引入设计模式优化代码机构，方便后期迭代。

1. 下单业务

   > 用户根据自己选择的商品，资料课程点击下单，创建一条商品订单，然后用户可以点击取消商品订单，或者去支付，点击去支付跳转到公司收银台，然后用户选择支付方式，选择好支付方式后提交，给商品创建一个支付订单，商品订单和支付订单式一对多的关系，用户点击付款之后，微信和支付宝会回调我们这边的接口，然后我们会修改订单状态，选择通知下游接口做对应的业务。其中还包括余额充值，组合支付，部分退款和对账等业务。

2. 微服务的一些配置

   > 技术栈: springcloud + gataway + sentinel + nacos + openfeign +rocketmq + redis +mysql
   >
   > 微服务:用户中心，风控，公共组件（mysql，redis，recketmq,）资源模块，支付模块，业务模块
   >
   > 表数据量: 上线前期大概200左右订单，后期有所增长，我离开的时候大概有500到1000，因为公司后期再用户中心做了一些推广。已上线6个月，核心商品订单表十一二万左右数据量。微服务部署了3台，服务器8核16g， jvm内存分配4g，free -h查看服务器内存占用情况，lscpu查看cpu详细信息，df -h 查看各个文件夹磁盘占用情况

3. 微服务之间数据传输有没有做权限校验

   > 对客端接口我们做了签名校验和请求时间判断以及是否登录判断，我们会在**拦截器通过和前端同样的算法进行签名计算，然后和前端传来的签名进行比较，如果一样则放行，请求时间也有判断，必须是当前时间五分钟内的请求才可以访问**，协议用的是https协议。对于公司内部调用的接口，我们加了签名校验，主要的校验还是通过代码逻辑判断，比如用户下单支付会判断这个用户存不存在以及当前支付用户是不是下单的用户支付，假如是余额支付还需要查询用户的余额是否够这次支付的金额，尽量不相信前端传到后端的参数。

4. 生成签名规则

   > 先排除请求时间这个请求参数key，然后对剩下的参数key通过大小进行排序再转成base64编码再通过md5加盐的方式进行加密，（为什么不用ase或者非对称加密，因为这两种算法比较复杂影响接口的性能，不是太多敏感信息的接口尽量不要用）
   >
   > 为啥先用base64然后用md5，因为base64在所有系统都是一样的生成规则，基于纯ASCII码，然后减少了Hash碰撞。

5. 关于开发人员

   > 四个后端，俩个前端，我负责微信支付宝的对接，退款和优惠券相关的业务，架构师主要开发资源的业务，还有权限这一块的业务，运维2个，测试一个。

6. 微服务之间的调用

   > 服务调用主要采用openFeign, duboo,有些也用MQ 主要看需不需要实时返回,

7. Openfeign的底层调用原理

   > 1. 在 Spring 项目启动阶段，服务 A 的OpenFeign 框架会发起一个主动的扫包流程。
   > 2. 从指定的目录下扫描并加载所有被 @FeignClient 注解修饰的接口，然后将这些接口转换成 FeignClientFactoryBean，统一交给 Spring 来管理。
   > 3. 在生产者接口注入时，根据这些接口会经过 MVC Contract 协议解析，将方法上的注解都解析出来，放到 MethodMetadata 元数据中。
   > 4. 基于上面加载的每一个 FeignClient 接口，会生成一个动态代理对象，指向了一个包含对应方法的 MethodHandler 的 HashMap。MethodHandler 对元数据有引用关系。生成的动态代理对象会被添加到 Spring 容器中，并注入到对应的服务里。
   > 5. 服务 A 调用接口，准备发起远程调用。
   > 6. 从动态代理对象 Proxy 中找到一个 MethodHandler 实例，生成 Request，包含有服务的请求 URL（不包含服务的 IP）。
   > 7. 经过负载均衡算法找到一个服务的 IP 地址，拼接出请求的 URL服务 B 处理服务 A 发起的远程调用请求，执行业务逻辑后，返回响应给服务 A
   > 8. 8、服务 B 处理服务 A 发起的远程调用请求，执行业务逻辑后，返回响应给服务 A

8. openfeign和dubbo的区别

9. 微服务部门有哪些

   > 工单中心，用户中心，资源部门；风控，资源规划，

10. 项目中redis用了哪些数据结构？

    > 1. String存订单号对应关系，过期key自动关单
    >
    > 2. Hash结构redission分布式锁 [https://www.cnblogs.com/vipstone/p/17940010](https://www.cnblogs.com/vipstone/p/17940010)

11. Mq用在什么地方？

    > 1. 用户支付成功后发送消息给下游通知支付成功，做下游的操作
    >
    > 2. 优惠券抢购成功后发送mq消息, 消费者处理将优惠券id和用户id插入数据库建立对应关系

12. 项目中有没有使用aop

    > 1. 日志打印
    > 2. 数据库的读写分离

13. 唯一的商品订单号和支付订单号怎么生成的

    > 用的雪花算法。
    >
    > 这个算法主要是用作分布式ID生成算法，使用一个64位的长整型数字作为全局唯一的ID。
    >
    > 1位未使用（二进制中为0，代表符号）
    >
    > 41位时间截 (毫秒级),存储时间截的差值（当前时间截 - 开始时间截），
    >
    > 10位的机器标识，可以部署在1024个节点
    >
    > 12位序列号，毫秒内的计数，同一机器，同一时间截，并发量可达4096
    >
    > **雪花算法你们有没有可能出现生生成重复的情况？**
    >
    > 服务器可能出现时钟回拨，导致雪花算法生成ID时使用了之前已生成ID的时间戳部分，进而可能产生重复ID。，但是这种情况我们数据库也加了唯一索引，如果一样会出现唯一索引冲突，代码中我们会对这个异常类型进行捕获，再次生成唯一id，一直会重试10次，10次后给用户提示错误信息，进行重试。

14. 异常怎么处理的

    > 异常通过俩种方式，一个就是基于AOP，一个基于adviceController注解 ，定义全局异常信息

#### **对接支付宝**

 1. 有哪些加密算法

    > Aes和rsa2，aes是对称加密，对传输的数据进行加密，rsa2是非对称加密，主要是验签，私钥加签，公钥验签。
    >
    > 支付宝先通过aes对传输的数据进行加密，然后再通过rsa2生成签名。

 2. ##### 怎么理解对称加密和非对称加密

    > 对称加密，加密的密钥和解密的密钥是一样的，非对称密钥不一样，一般是公钥加密，私钥解密，对签名来说，私钥加签，公钥验签。 为什么不是私钥加密，公钥解密 。因为如果公钥解密，所有人都可以解开。

 3. ras2加密原理

    > RSA的安全性建立在 **“大数质因数分解的极端困难性”** 之上。简单来说，将两个巨大的质数相乘非常容易，但想将这个乘积分解回原来的两个质数，以目前的计算能力来说，在有限时间内几乎是不可能的。

 4. 分页用的什么实现的，原理知道吗？

    > 用的pagehelper，核心原理是将传入的页码和条数赋值给一个Page对象，并保存到本地线程ThreadLocal中，PageHelper会进入Mybatis的拦截器环节，在拦截器中获取并处理刚才保存在ThreadLocal中的分页参数。这些分页参数会与原本的SQL语句和内部已经定义好的SQL进行拼接，实现分页查询。

 5. 关于支付宝对接的一些细节

> ***\*商家中心\*******\*：\****可以看每天的交易数据，账户金额（一般企业核心领导才有权限登录）
>
> ***\*开发平台\*******\*：\****对接相关支付接口，进行支付相关配置（只有产品或者项目经理有权限，开发只能在沙箱环境测试）
>
> ***\*注意\****:企业中开发人员只能在沙箱环境进行调试，企业不会把正式的账号给开发，所以开发人员沙箱环境调通了，测试完成后需要把与正式环境区别的配置记录一下，然后由产品经理用正式环境的企业支付宝账号在开发人员的帮助下进行注册和一些配置的申请，最终将一些配置参数通过内部邮件的方式发生给开发，然后开发进行正式环境的配置和上线。
>
> - 怎么和支付宝对接的？（重要）
>   - 产品先通过企业的一些材料申请一个企业账号，然后登录进开发平台，先创建一个应用（智学网在线支付），然后在应用中添加能力（能提供哪些支付方式），我们目前网站做的就是网站在线支付能力，所以配置后然后需要支付宝那边审核，一般审核1-3天，审核通过后产品登录商家中心，通过商家账号关联该应用id，正式环境配置就完成了。
> - **需要传哪些参数给支付宝？（重要）**
>   - 公参有对于开发来说我们需要的是appid也就是应用id，应用私钥（调用支付宝任何接口进行加签，支付宝用应用公钥验签）和支付宝公钥（用户支付成功支付宝回调我们接口进行通知的时候加签，我们会用支付宝公钥在回调接口中进行验签），aes密钥（参数传输过程中进行加密），以及支付宝的网关地址（支付宝相关接口域名）和协议名称（https），还有一个回调地址(这个是我们自己写的接口,支付宝那边扣款成功后需要将结果反馈给我们服务，我们需要在这个接口做支付成功后的业务操作)，还有一个return url，这个是支付宝支付成功后，跳转到哪个前端页面，这些配置都保存在配置中心。
>   - **业务参数有：**支付宝下单（支付）接口需要的业务参数 
>     - 1.商户订单号（支付订单号），
>     - 2主题（商品名称），
>     - 3金额(元为单位) 
>     - 4.支付宝网址支付固定字符串（电脑快速支付固定字符串，没什么意义，手机又是另一个字符串，主要区分支付来源），调用后支付宝支付接口返回的是一个表单，里面带有支付的一些信息，比如商户订单号，金额之类的数据，这个表单会自动提交，提交后会返回支付二维码，由用户进行扫码支付，用户扫码或者登录后支付宝那边会生成支付订单，用户付款成功后，支付宝会回调我们提供的回调接口通知我们用户支付成功，我们在回调接口中处理后续具体的业务，比如余额充值就给用户加余额，用户购买商品就把用户id和商品id传给商品部门，他们放开用户查看和下载商品的权限。用的是支付宝easysdk。

6. 开发直接更改了数据库用户余额怎么办

   - 生产环境只有读权限，DBA才有权限

7. 第三方回调你们接口，接口中出了异常了怎么办？(你们回调通知完全依赖第三方吗？假如第三方一直没有回调怎么办)（重要）

   > 这个要分两种情况，第一种就是用户付款成功了但是支付宝那边一直没回调我们这边的接口，这个我们服务有写一个定时任务，每隔3分钟查询今天待支付的支付订单，然后主动调用第三方渠道支付状态查询接口查询支付状态，如果返回支付成功直接调用支付成功后的业务方法，所以这个方法一定要做好幂等性。
   >
   > 第二种就是我们回调接口里面业务有异常，这个我们加了事务，有异常整个事务回滚，后面异常修复了可以再次重试，不会有脏数据。然后定时任务重试的时候会记录一下每一笔支付订单的重试次数，如果到达了3次会打印error日志，我们公司服务治理平台会对error日志进行检测，如果检测到了会将日志信息推到钉钉群，艾特对应的开发进行定位和解决。

8. ##### **如何防止用户重复下单的或者重复创建支付订单？（重要）**

   > 这个我们前端有处理，前端用户点击按钮后会在跳转页面之前进行置灰，后端我们主要采用预订单的方式，在页面跳转之前先调用服务器的接口申请一个唯一的订单号，然后作为这一次页面的提交凭证，对这一次页面即使用户多次点击但是传给后端的商品订单号是一样的，这样数据库就会有唯一索引限制，只能成功一个。

9. ##### **为什么不通过用户id和商品id在数据库的唯一索引？（重要）**

   > 商品id和用户id在数据库不能唯一，因为有可能用户对这个商品创建订单后取消了几次又创建一个新的，那么数据库这个用户这个商品id就会对应多条数据，如果从数据库唯一索引对商品id和用户id进行唯一限制，那么就会导致用户取消了该商品订单就不能再重新购买该商品

10. **还了解其他防止重复提交的方式吗****？**

    > 也可以用分布式锁，比如可以用用户id和商品id进行加锁，然后锁里面通过用户id和商品id查询数据库是否有待支付的商品订单，如果有直接让用户跳转支付页面，如果没有再进行创建，但是这样接口的并发性会比较差，因为每一笔订单都会加锁。

11. 如何防止重复支付问题

    > 重复支付在我们项目中主要有两个场景，
    >
    > 第一个场景就是重复提交问题，比如一个用户创建了两笔一样的订单，就可能出现重复支付，对于这个问题我们前端有处理，前端用户点击按钮后会在跳转页面之前进行置灰，后端我们主要采用预订单的方式，在页面跳转之前先调用服务器的接口申请一个唯一的订单号，然后作为这一次页面的提交凭证，对这一次页面即使用户多次点击但是传给后端的商品订单号是一样的，这样数据库就会有唯一索引限制，只能成功一个。
    >
    > 第二个场景就是用户在收银台页面进行切换渠道的时候也需要防止用户重复支付，这块主要可能用户先用微信支付已经返回二维码了但是用户没扫码退出了然后又打开收银台用支付宝进行了支付后又扫了之前打开的微信二维码，这样就重复支付了。对于这种场景我们在用户进行渠道切换下单返回支付二维码之前会先判断该商品订单下所有的支付订单并依次调用对应的第三方支付渠道查询判断是否该商品已有支付订单已经支付了，如果有直接抛异常，提示用户该订单已支付，请勿重复支付。如果查询的其他支付订单都是待支付状态，我们会先把这些待支付的支付订单依次进行关单，然后在创建目前这笔新的支付订单，并调用第三方渠道进行下单拉取二维码，这样就解决了扫2次码的问题，虽然可能返回两个二维码，但是第二个二维码返回的时候已经对第一个二维码的订单进行了关单，用户即使扫第一个二维码也支付不了。但是有一种场景比较麻烦，这种没法解决，就是支付宝电脑网站支付有个小问题，用户扫码或者用账号密码登录后支付宝那边才会有订单，假如有极端情况，用户先用支付宝支付，展示二维码但是用户没扫码，接着用户选用微信支付，然后用微信支付成功了，后面又用之前支付宝二维码支付了一次，这种极端情况没法避免，因为支付宝扫不扫码跟我们服务没有交互，没扫码支付宝那边没订单我们也没法进行关闭，这种情况我们只能靠后续对账以及用户自己反馈进行人工退款
    >
    > **这种特殊的场景如果让你们程序自动退款能实现吗，不需要人工介入？**
    >
    > 也可以实现，这个可以在回调接口中通过当前支付订单号查询关联的商品订单，然后再通过商品订单查询除了当前支付订单外其他的支付订单，然后依次查询第三方支付状态，如果有支付成功的，对当前这笔支付订单调用退款接口进行退款，不过当时也和产品商量过，他们还是希望这种重复支付问题能让他们知道，走退款审批流程，不让我们在代码中直接处理。

12. ##### **为什么用户切换不同渠道创建支付订单你们不是在原有的支付订单数据修改订单号和渠道，而是新增一条支付订单？（重要）**

    > 这个主要是后期用户可能出现重复支付需要给用户退款，如果覆盖就找不到对应的支付订单，而且覆盖对问题追踪不方便。

13. **你们前端购买商品包括价格直接传给后端假如数据被篡改了怎么办**？（重要）

    > 这个后端我们服务用的是https协议，对于有金额等敏感信息的接口参数也通过aes加密算法进行了加密并且还额外用了md5加盐的方式对接口参数计算了一个签名sign传给服务端，如果服务端先通过同样的md5加盐的方式算了一下签名，先对比签名是否一致，如果一致说明没有被篡改，然后一致再通过aes对称加密解析出参数明文，并且后端接口内也有校验，会拿金额和订单id查询数据库的订单金额和前端传的金额是否一样。

14. ##### **对https协议了解吗（重要）**

    > 聊到这个协议先说下非对称加密算法，非对称加密一般是公钥验签，私钥加签，公钥加密，私钥解密，这个顺序不能反。
    >
    > 1.客户端发起请求
    >
    > 用户在浏览器中输入一个HTTPS URL（如https://www.example.com）。
    >
    > 浏览器向服务器发起一个HTTPS连接请求。
    >
    > 2.服务器响应并发送证书
    >
    > 服务器收到请求后，将其数字证书发送给客户端。数字证书包含服务器的公钥和由可信的证书颁发机构（CA）签名的信息。
    >
    > 3.客户端验证证书
    >
    > 客户端收到服务器的证书后，会进行以下验证步骤：
    >
    > 验证证书的完整性和签名：使用CA的公钥验证证书的签名，确保证书没有被篡改。
    >
    > 检查证书的有效期：确认证书在有效期内。
    >
    > 验证证书的颁发机构：确认CA是受信任的机构。
    >
    > 检查证书吊销状态：通过证书吊销列表（CRL）或在线证书状态协议（OCSP）检查证书是否被吊销。
    >
    > 4.生成会话密钥
    >
    > 如果证书验证通过，客户端会生成一个随机的对称密钥（也称为会话密钥），用于加密会话中的数据。
    >
    > 客户端使用服务器的公钥加密这个会话密钥，并发送给服务器。
    >
    > 5.服务器解密会话密钥
    >
    > 服务器使用其私钥解密会话密钥。
    >
    > 此时，客户端和服务器都持有相同的对称密钥，用于加密和解密后续通信中的数据。
    >
    > 6.加密数据传输
    >
    > 客户端和服务器使用生成的会话密钥对传输的数据进行加密和解密。
    >
    > 所有传输的数据（如HTTP请求和响应）都通过加密通道进行，确保数据在传输过程中保持机密性和完整性。
    >
    > 我们接口内部也有校验，我们会通过前端传来的订单id，先查询订单数据库是否存在，还要判断当前的下单用户是否是创建订单的用户，并且该订单状态需要是待支付状态的。并且前端传过来的金额还和数据库订单金额一致才可以继续后续的业务

15. 你们金额用的是什么数据类型？（重要）

    > 数据库用的decimal ，java用的BigDecimal使用十进制存储数据，可以精确表示任意精度的小数。（oracle数据库用的number，和bigdecimal效果一样。）
    >
    > 数据库用的decimal，因为微信支付宝有元为单位的，也有分为单位的，我们都是用小数统一存储，没有*100进行取整，不然经常转换容易转错。
    >
    > ##### **BigDecimal常用的方法 （重要）**
    >
    > 1.add(BigDecimal)
    >
    >  
    >
    > 2.subtract(BigDecimal)
    >
    > 3.multiply(BigDecimal)
    >
    > 4.divide(BigDecimal)
    >
    > 5.negate() 取反
    >
    > 6.abs()绝对值

16. 查询订单状态什么业务需要，并且怎么实现的？

    > 1. 目的是防止用户支付了金额支付宝异步通知很久没有通知导致后续业务没有进行，例如用户充值了50元但是余额一直没有增加，因为支付宝还没将支付状态传给回调接口导致用户反馈或者回调接口处理后续业务时报错等开发解决后需要再次查询支付宝订单状态重新走一次支付成功逻辑。
    >
    > 2. 在进行关闭订单的时候需要先查询一下支付宝那边的支付状态，不能直接关闭，因为可能商品订单状态还是待支付，但是用户已经支付了只是支付宝没有及时通知支付状态给我们服务，所以关闭订单的时候我们需要调用支付渠道主动查询订单支付状态。
    >
    > 怎么实现的？
    >
    > 和创建订单公共参数是一样的，也需要密钥和私钥等，但是业务参数有区别，查询订单状态，只需要传商户订单号这一个参数给支付宝就可以，支付宝会返回这笔订单的支付状态，如果支付成功再次走一遍支付成功后的业务（所以支付成功这个接口一定要做好幂等性）。

17. ##### 什么时候需要关单并且怎么做的？（重要）

    > 第一个用户创建一个商品订单后如果五分钟后还未支付我们需要对这笔商品订单以及商品订单下所有的支付订单进行关单。（不仅仅是我们数据库改状态，还需要调用支付宝或者微信把他们那边该笔订单也关闭）。
    >
    > 第二个是当用户换渠道进行支付的时候我们需要对之前创建的待支付的支付订单进行关闭。
    >
    > 第三个是用户主动点击取消订单按钮。

18. **延迟关单是怎么做的****？（重要）**

    > 1. 关单的话主要有几种方式， 我们是基于订阅redis过期key来做的
    >    	- 定时任务
    >    	- 订阅redis过期事件
    >    	- rocketMQ的延迟消息
    >     - 甚至基于java代码也可以做
    > 2. 关单逻辑
    >    - .先通过该商品订单id查询商品订单表该笔商品订单是否存在，如果不存在或者已支付则不进行任何操作，如果是未支付状态需要找到该商品订单下所有的支付订单然后依次调用第三方渠道查询支付状态接口查询支付状态，如果都是未支付状态则先调用所有的第三方渠道关单接口先把对于该条商品订单第三方创建的支付订单进行关闭，第三方支付订单所有都关闭成功后再将数据库商品订单表该条商品订单和该条商品订单下所有的支付订单状态改成已关闭，只要第三方渠道有一个渠道返回支付状态是支付成功则关单失败，提示该订单已支付，无法进行关单

19. **建立一张表需要考虑哪些因素？**

    > 1. 第一个是要遵循三大范式，如果表数据量比较多不想经常进行关联查询也可以反范式减少联合查询。
    >
    > 2. 第二个就是要设置合适的字段类型，比如定长用char，不定长字符串用varchar，像状态这些用tinyint减少存储空间。
    >
    > 3. 第三个就是建立合适的索引，增加查询速度，重复多的不适合建立索引，经常查询的多个字段可以建立联合索引。
    >
    > 4. 第四个就是设计合适的关联关系，1对多在多的那张表关联的主键id，多对多要额外建立一张中间表做关联。
    >
    > 5. 第五个就是要设计合适的主键，如果数据量少，比如低于1000万级别，那么一张表就可以，主键自增，不需要分库分表，如果后续表的数据量比较大上千万，主键就要合理设计唯一，比如雪花算法。
    >
    >    第三范式
    >
    >    > 第一就是所有列是原子性，不能分割，第二是字段需要强依赖不能部分依赖，第三就是不能出现依赖传递。

20. ######  **回调接口中你们做了什么业务？（重要）**

> 整个过程在一个事务内
>
> 1. 验签，调用支付宝提供的验签方法，用支付宝公钥进行验签，保证该通知是从支付宝发过来的
>
> 2. 获取入参中的商户订单号(支付订单号)，查询是否数据库存在并且状态是待支付状态
>
> 3. 获取支付状态，如果是支付成功执行支持成功逻辑
>
> 支付成功详细逻辑
>
> 1. 将商品订单状态改成已支付
> 1. 将支付订单改成已支付
> 1. 如果该订单类型是余额充值，给用户账户增加充值的金额，如果是购买某种商品，将商品id和用户id传给商品部门进行权限放开
> 1. 如果用户用到了组合支付（余额和渠道支付都有），则解冻余额并扣款。

21. 支付成功后你们怎么防止支付宝重复通知的（幂等性怎么解决的）？（重要）

    > 这块我们是用两种方案解决的，
    >
    > 第一种我们更新商品订单状态和支付订单状态的时候会根据数据库已有的状态进行更新，如果数据库状态是待支付状态我们才更新，如果是已支付状态说明已经处理过一次，直接返回不进行后续业务操作。相当于用订单状态做了一个乐观锁。
    >
    > 第二种就是在方法结束向防重表插入一条数据，以支付订单号做了唯一索引，处理成功后将支付订单号做唯一索引插入一张防重表，这样即使重复通知，但是重复通知的支付订单号都一样，所以第二次插入会报错整个事务回滚。

22. **还有什么方式可以解决幂等性问题吗（重要）**

    > 也可以加分布式锁，先抢锁，锁内查询数据库商品订单状态，如果是待支付，将状态改成已支付，提交事务，释放锁。

#### 微信对接问题[https://pay.weixin.qq.com/doc/v3/merchant/4012062524](https://pay.weixin.qq.com/doc/v3/merchant/4012062524)

> 微信支付比支付宝要麻烦一点，但是原理差不多，也是先下单再由用户扫码支付，支付完成后回调我们提供的接口更新订单状态和后续业务，但是微信的api第一个参数没有封装好，需要我们自己封装请求参数，第二个微信的公钥并不是固定的，他们会定时更新公钥和私钥，所以需要我们每次通过接口获取最新的微信公钥，微信的金额是分，所以我们还要乘100，支付宝是元。
>
> 微信需要的参数：应用id，商户号，证书序列号，然后商户私钥，apiv3Key（密钥），回调地址
>
> 微信总金额数据类型是int类型，当时没有转换导致返回bad request，请求参数错误。调用成功后微信返回一个二维码的链接，支付宝是返回表单。
>
> 微信异步通知也比较麻烦，涉及到参数的解密问题，回调接口的时候需要一个证书序列号，这个我之前以为是直接从配置文件获取，但是实际是需要从微信回调的请求头中获取。

#### 二.开发用户余额账户余额充值功能并对比不同开发方案并选用最优方案开发用户余额和渠道组合支付功能。

1. ##### **怎么开发账户余额充值功能的？**

   > 我们每个用户都会有一个账户，账户表在支付这边，用户可以对自己的账户进行充值，充值后可以用余额抵扣购买商品，用户首先点击余额充值，会为这次充值创建一个商品订单，商品订单类型的余额充值，然后用户对这笔订单进行支付，可以选择支付宝和微信支付，支付完成后回调接口中通过乐观锁给用户增加余额（防止充值多次并发更新余额导致丢失更新问题），并且还用了一张防重表，表里面记录了商户订单号，支付宝订单号和金额，对商户订单号进行了唯一索引限制，这样解决了幂等性问题，既支付宝针对这笔支付订单支付了多次也只有一次能够成功。

2. 组合支付怎么开发的？（重要，可作为一个有挑战性的需求）

   > 组合支付就是用户用余额抵扣的形式，比如一笔订单100元，账户余额还剩80，那么他就可以用余额抵扣80，渠道支付20,。
   >
   > 当时我想到有3个方案，但是前两种都有点问题，第一种就是在用户对创建的商品订单点击去支付的时候直接扣除余额，然后再让用户进行渠道支付，给用户返回二维码，这种问题点在于用户可能还没扫码付款，但是余额会莫名其妙被扣除导致用户投诉，另一种方案就是用户对创建的商品订单点击去支付的时候不做任何操作，在用户扫码支付成功后回调接口中进行扣除余额，这种方案我刚开始觉得可以，但是后面讨论后发现有bug，因为存在用户对不同商品创建多个商品订单的可能，比如用户支付100元时选择用余额抵扣50，渠道支付50，并且扫码支付成功了但是由于支付宝那边通知比较慢，导致用户余额没被扣除，用户又创建了另一笔商品订单，但是由于之前余额没被扣除，还可以继续用余额50元进行抵扣，就导致50元余额被抵扣了多次，这样就非常麻烦，因为同时抵扣了50，但是回调接口中只有一个50能够扣余额成功，另一个扣余额会失败，但是用户渠道支付又成功了，余额扣除失败了，不能给用户发货，也不能给用户退款，导致用户投诉。所以最后采用了第三种方案，就是余额冻结的这种形式，逻辑就是用户支付100元时选择用余额抵扣50，渠道支付50点击去支付时先冻结这部分余额，然后再进行渠道支付返回二维码，如果支付成功后回调接口中解冻并扣除这部分余额。如果用户取消订单则解冻该冻结的余额，或者订单超时了也解冻该冻结的余额，这样用户只要用余额抵扣了整个流程没有闭环，那么这部分余额始终被冻结，不能进行其他操作，所以不存在重复抵扣的过程。

3. ##### **组合支付逻辑的什么样的？（重要）**

   > 首先用户选择商品订单点击去支付的时候前端会传需要渠道支付金额，需要账户抵扣的金额，渠道类型到服务端，服务端会判断如果渠道金额为0，账户金额不为0就采用账户抵扣，直接数据库扣除账户的金额，这种比较简单，不涉及第三方渠道支付。如果渠道金额不为0，账户金额为0我们就采用渠道支付，调用第三方渠道下单接口，拉起支付二维码，如果两者金额都不为0说明采用组合支付，先冻结这次余额抵扣的金额，然后再调用第三方支付下单接口返回二维码，用户支付完成后，回调接口中解冻该余额并进行账户扣款（乐观锁），然后进行后续支付成功业务操作。

4. 你们先冻结金额还是先渠道支付？（重要）

   > 我们先冻结余额抵扣金额，再调用第三方下单接口返回支付二维码，这样就不会有事务问题，如果先调用第三方接口下单成功，但是后续冻结失败了就导致事务不一致，所以先冻结再调用第三方下单接口，这样第三方下单接口失败了整个事务回滚。

5. ##### 如果极端情况，比如你们已经延迟关单了，但是用户这时候刚好支付了，你们怎么处理？（重要）**

   > 这块但是有考虑到，要分谁先执行谁后执行，如果用户先支付成功了，关单时候调用第三方查询支付状态，如果是已支付则关单失败，正常进行支付成功逻辑。如果是关单先执行已经把数据库状态改成已关闭，支付成功通知后面到的，这块问了产品，产品说还是以支付成功为主，这里不进行退款，就是在支付成功回调的时候如果数据库该笔支付订单的状态是已关闭或者待支付，把状态改成支付成功，正常进行后续支付成功的业务。

6. 冻结余额有没有什么参数校验？

   > 有，第一我们会校验冻结余额不能为0，第二会校验该账户是否存在，第三会判断目前冻结的金额是否小于可用余额，然后再采用乐观锁去更新冻结金额。
   >
   > 问题：这块我当时做的时候没有考虑重复冻结的问题，我每次冻结金额直接覆盖数据库目前冻结的金额，比如用户下了两个订单，应该要冻结两笔金额进行累积，但是我开发的时候没注意这种情况，测试的时候测出来了，后面改为从数据库取出目前的冻结金额然后加上现需要冻结的金额再更新进数据库。

7. **冻结金额具体是怎么实现的？**

   > 这个我们主要是在数据库账户表维护一个冻结金额字段，对用户冻结这次行为还要加一条冻结的详细数据记录数据到记录表，用户多次抵扣能够实现冻结金额累加。

**三.开发全额退款、部分退款以及组合退款优先退余额等相关逆向业务。（了解）**

> ​	***\*支付宝部分退款要传哪些参数？\****
>
> 首先公参都需要传，商户私钥，密钥，appid等，业务参数有商户订单号和退款请求号（部分退款每次这个都要求不一样，如果一样只会退一次）以及退款金额。
>
> ***\*什么场景\****
>
> 我们用户有的时候买的材料可能会觉得里面有些跟他预期的不一样，或者用户买错了材料用户和运营进行沟通，公司防止用户进行投诉或者曝光会选择和用户进行商量进行部分退款或者全额退款。
>
> ***\*怎么开发的\****（重要）
>
> 全额退款功能比较简单，用户和运营沟通好后，运营会根据这笔支付订单先提交一个退款申请单给领导进行审核通过过根据支付渠道调用第三方退款接口进行全额退款。如果当时用户购买商品用的是余额支付就直接给用户增加余额，并通知下游的资源部门进行用户和商品进行解绑。
>
> 比较复杂的是部分退款，因为用户购买一个商品可能用到了组合支付，既又有余额抵扣，又有渠道支付，我们公司产品要求是优先退余额，余额退完了再退渠道金额，这个业务我在代码中会先把余额和渠道各退多少的金额先计算好，然后再调用具体的功能接口进行退款。

 

```java
 if (oriAccountAmount.compareTo(BigDecimal.ZERO) == 0) {
            LOG.info("余额抵扣=0，则只退渠道");
            accountRefund = BigDecimal.ZERO;
            channelRefund = refundAmount;
        } else if (oriChannelAmount.compareTo(BigDecimal.ZERO) == 0) {
            LOG.info("渠道支付=0，则只退余额");
            accountRefund = refundAmount;
            channelRefund = BigDecimal.ZERO;
        } else {
            if (hadRefundAmount.add(refundAmount).compareTo(oriAccountAmount) <= 0) {
                LOG.info("已退金额 + 本次退款金额 <= 余额抵扣，则只退余额");
                accountRefund = refundAmount;
                channelRefund = BigDecimal.ZERO;
            } else if (hadRefundAmount.compareTo(oriAccountAmount) >= 0) {
                LOG.info("已退金额 >= 余额抵扣，则只退渠道");
                accountRefund = BigDecimal.ZERO;
                channelRefund = refundAmount;
            } else {
                LOG.info("其它，则退余额 + 退渠道");
                // 原交易支付100 = 余额50 + 渠道50<br>
                // 已退40，本次退20，则余额退10，渠道退10<br>
                accountRefund = oriAccountAmount.subtract(hadRefundAmount);
                channelRefund = refundAmount.subtract(accountRefund);
```

1. 组合退款你们怎么知道到底退余额还是退渠道还是两者都退

> ​	这个我们会根据数据库已退金额进行计算，举个例子，如果100元的商品用户渠道支付了50元，余额抵扣了50元，用户现在退20元，那么我们就会将20元和数据库已退金额进行累加然后判断是否小于或者等于余额抵扣的50元，如果是，只退余额就可以了。然后用户现在退20，但是数据库已退金额是60，已退金额已经大于或等于余额抵扣，所以这20元只退渠道。如果现在退20元，数据库已退金额小于50，但是当前退的金额20元加已退金额大于50元，则余额退50-数据库已退金额，渠道退20-（50-数据库已退金额）

你们有出现过本地退款失败但是渠道退款成功的情况吗？\****（重要）

> 没有，我们退款逻辑是先退本地再退渠道，如果渠道退款失败我们会抛异常，整个退款逻辑回滚不会出现事务不一致的情况，如果有代码bug开发先解决，然后运营再次发起退款。

开发管理员退款审批功能，并采用seata处理微服务之间调用出现的分布式事务问题。[https://www.bilibili.com/video/BV16h4y1G7kd/?spm_id_from=333.337.search-card.all.click&vd_source=8db2bf2ffb3ab22965fccab48d4389ba](https://www.bilibili.com/video/BV16h4y1G7kd/?spm_id_from=333.337.search-card.all.click&vd_source=8db2bf2ffb3ab22965fccab48d4389ba)

##### 你们项目中什么场景会有分布式事务产生？

> 主要有两个场景，在运营人员给用户退款和调用下游部门放开权限这两块。
>
> 用户可能对购买的材料不太满意，需要退款，然后沟通后运营选择全额退款或者部分退款。运营会先创建一个退款的申请单保存在我们这边申请表中，并同时把申请信息传给工单那边（其他微服务部门），然后工单那边会同时返回一个审核领导的id，然后我们再把id更新进我们这边这条申请单中，然后记录表插入一条申请单生成的记录，所以就有分布式事务产生，假如我们更新领导id的时候失败了，导致本地事务回滚，但是工单部门那边会多一条待审核脏数据。
>
> 第二个就是支付成功后我们会调用下游接口进行资源权限放开，但是这块就可能网络问题导致下游权限已经放开了，但是返回报错导致支付这边事务回滚，但是下游用户和资源权限已经解绑成功，就出现事务不一致问题，下游多了一条脏数据。

##### 谈一谈你对分布式事务的理解？（什么是分布式事务）

> ***\*先说是什么：\****这个我先从说下本地事务，像本地事务同一个数据库链接事务就有acid特性，所以要么同时成功要么同时失败，但是对于分布式事务一般是在跨服务之间调用或不同的数据库操作，这样数据库链接不一样，不在同一个事务，所以就会出现分布式事务问题，即如果不处理就会出现不同服务之间数据不一致问题。举个例子，假如现在有三个微服务，订单，库存，积分。下单成功后，扣库存，加积分，那么就可能出现，订单服务中下单成功，扣库存成功但是加积分失败了就会导致订单本地事务回滚，但是库存因为在其他微服务，所以库存依然被扣了，整个过程数据不一致。
>
> ***\*然后再说下分布式事务解决方案的思想:\****然后我再说下解决分布式事务的一些理论，比如cap定律和base理论，cap定律就是在微服务的情况下分区容错性肯定存在，既只能满足ca（可用性）和cp（一致性）其中一种，为了解决这个只能满足其中一种的问题又引入了base理论，既基本可用，允许中间状态以及最终一致性。
>
> ***\*再说下我了解的分布式事务框架\****，分布式事务解决方案基于base理论实现的。比如拿seata的xa模式来说，虽然保证了强一致性，但是牺牲了基本可用性，因为强一致，所有分支事务会互相等待对方最终执行结果再进行统一提交或者回滚，而这个时候数据库操作的数据资源会被锁定，短暂的不可用。而seata的at模式则牺牲了强一致性保证了最终一致性。所有的分支事务执行完后会直接提交，不会造成锁资源的情况，如果有其中一个事务执行失败了，其他提交成功的事务采用反向补偿的方式进行处理，能够保证最终一致性，性能上面比xa模式更好，还有seata提供的tcc实现方式也是保证了最终一致性，回滚与xa的区别是xa有seata框架实现自动补偿，而tcc是需要通过手动编码的方式实现补偿。

##### **怎么引入seata的？**

> ***\*Tc（seata中tc角色，他是以服务器的形式存在）微服务搭建：\****
>
> 这个seata服务器集群是运维搭建的，运维搭建好后我需要在创建一个seata数据库，数据库中创建两张表，一个是全局事务表，一个是分支事务表，然后将seata配置文件指定一下注册中心类型和配置文件保存的方式，我选用的是服务器注册进nacos，并在nacos 创建了seata服务器的配置文件，把seata数据库ip地址用户名密码以及全局事务表和分支事务表名配置进seata的配置文件。
>
> 1. 先引入依赖spring-cloud-starter-alibaba-seata
>
> 2.  在每个微服务中配置文件指定一下seata注册的ip地址，命名空间，组，应用名称以及集群的映射关系（这样每个微服务才可以连接上seata服务器做事务控制）
>
> 3. 每个微服务配置文件指定一下seata数据源的代理模式（XA或TCC或At）
>
> 4. Java代码上要加@GlobalTransational注解
>
> 5. **Seata三个核心组件的功能？*****\*（重点）\****
>
>    **TC‌：**TC负责管理全局事务的生命周期，记录全局事务状态和分支事务的状态，协调各分支事务的提交或回滚操作。
>
>    ‌位置‌：通常部署为一个独立的中心化服务，例如Seata Server。
>
>    ‌工作原理‌：TC接收TM注册的全局事务请求，分配全局事务ID（XID），协调各分支事务的提交或回滚**‌**
>
>    **TM‌作用‌：**TM负责发起并管理全局事务的边界，包括开始、提交或回滚事务。
>
>    ‌位置‌：嵌入到业务服务中，是分布式事务的入口。
>
>    ‌主要功能‌：TM向TC注册全局事务，获取全局事务ID，管理事务的开始和结束，根据业务逻辑或异常通知TC提交或回滚事务**‌**
>
>    **RM‌：**‌作用‌：RM负责管理和操作特定资源（如数据库、消息队列等），与TM进行交互，执行具体的数据库操作或资源操作。
>
>    ‌位置‌：部署在各个业务服务中。
>
>    ‌主要功能‌：RM将资源注册到TC，报告分支事务的状态，并在全局事务提交或回滚时完成实际的提交或回滚操作
>
>    ##### **17.3 XA模式流程图（不合适，因为这个数据核心接口，并发要求高）**
>
>    ***\*优点\****:满足强一致性，没有代码侵入
>
>    ***\*缺点\****:锁定数据库资源，等待时间久，因为必须要所有事务都执行完毕才可以提交或者回滚，资源锁定时间长。依赖于数据库的事务，因为最终提交和回滚最终还是数据库事务完成。
>
>    ##### **17.4 AT模式流程图（比较合适）**
>
>    
>
>     
>
>     
>
>     
>
>    ![img](https://leslieyedoc.oss-cn-shanghai.aliyuncs.com/img/20250919-164120-wps1.jpg) 
>
>     
>
>     
>
>     
>
>     
>
>     
>
>     
>
>     
>
>     
>
>     
>
>    
>
>    |      |                                                              |
>    | ---- | ------------------------------------------------------------ |
>    |      | ![img](https://leslieyedoc.oss-cn-shanghai.aliyuncs.com/img/20250919-164133-wps2.jpg) |
>
>     
>
>    
>
>    和at模式区别:多建立两张表，全局锁表，undolog表，然后每个微服务配置文件要把代理模式改成at。
>
>    ***\*优缺点\****：不锁定资源，效率高，无代码侵入性
>
>    生成快照需要耗费一定时间，只能保证最终一致性。
>
>    使用全局锁（跟数据库锁没关系，是seata生成的，所以没有数据库锁粒度那么大）实现数据隔离（现在重点说一下什么是全局锁
>
>    全局锁就是全局锁表的一条记录，有事务id，表名和操作的记录id等(唯一联合索引)，现在有一个seata控制的事务修改数据库一条数据要先拿到数据库锁，再拿到全局锁，才能修改表数据，所以当seata第一阶段提交把100改成了80释放数据库锁，这个时候全局锁还没有释放，因为还没有到第二阶段。后面其他seata控制的事务拿到了数据库锁再拿到全局锁时发现拿不到，就会一直重试，每隔10ms重试30次后释放，假如这个时候TC要回滚，先拿数据库锁（为什么要加入重试次数超时释放，不然就会出现死锁，a要拿数据库锁拿不到，但是拿到了全局锁，b要拿全局锁拿不到，但是拿到了数据库锁，所以要引入超时自动释放，释放了数据库锁），然后再拿全局锁，然后再回滚快照，这样就避免了另一个seata控制的事务把80改成了70，结果又回滚成了100。
>
>    ##### **TCC模式(不太合适，es更新交给了cannel，都是数据库操作，而且还会增加代码的复杂性)**
>
>    需要手动编码，try执行业务，预留资源  confirm提交  cancel回滚
>
>    ***\*优点：\**** 一阶段直接提交事务，不需要生成快照也不需要生成全局锁，性能最好
>
>    不依赖与数据库事务，只需要写补偿方法。
>
>    ***\*缺点：\****代码侵入，最终一致性，需要解决一些问题，比如空回滚，悬挂，幂等性等。
>
>    ***\*空回滚:\****try卡住了，最后超时回滚，导致try没被执行，cancel被执行了，所以可以在cancel的时候先判断一下try有没有执行，比如try执行完成后再去数据库维护一张表，插入一条记录，如果cancel通过事务id查询这条记录存在则进行回滚，不存在也要插入一条记录，该记录的状态为cancel，证明回滚过了，要保证幂等性，所以在进行补偿的时候还需要判断一下这条记录的状态，如果是取消状态直接返回ture，不进行补偿操作。悬挂的意思是try卡住了没执行，事务回滚了，但是try又恢复了，导致try被多执行了一次，事务不一致，所以执行cannel的时候业务表里面插入一条记录，执行try的时候先查询这张表里面有没有记录，如果没有则不进行预留资源操作。
>
>    Seaga了解的比较少，有点像xa和tcc的结合版本，处理长事务比较有优势，基于事件驱动执行每个子事务，所以每个子事务不需要串行执行，但是也要写回滚代码
>
>    #### 那假如这个事务不是由seata控制的修改了怎么办？
>
>    这个seata有个后置镜像，相当于乐观锁，回滚之前会判断一下初始值是不是跟原来的一样，如果是一样才进行回滚，不一样会报错，这个就需要人工处理了
>
>    ##### **为什么选用at模式来处理你们的分布式事务？（重要）**
>
>    Xa模式性能很差，属于二阶段提交不太合适我们的场景，at模式基于快照补偿方式，第一阶段就已经提交了，所以并发性比较好，但是at模式会有丢失更新的问题，不过我们这些场景都是新增业务，把申请单数据传给工单部门和用户资源权限解绑都是其他微服务部门新增一条数据，这样at模式非常合适，因为基于快照只需要删除数据就行了，速度非常快。Tcc有代码侵入性，而且需要处理空回滚和悬挂问题，tcc比较适合频繁更新某一个字段的操作，比如扣减库存，他是原理是实现数据隔离，避免锁定资源。
>
>    ##### **还知道哪些分布式事务处理方式？**
>
>    还知道本地消息表，这个像rocketmq有个半事务消息，发消息的时候该消息不能消费，本地事务先执行，如果本地事务成功，则发送确认消息，消费者实现消费，本地事务失败可以发送回滚消息则丢弃该消息。最大努力通知就是通过不同的时间段一直给你发送消息，像支付宝支付成功发送更新订单状态的请求就是用的最大努力通知。只要没给确认就会间断性一直发送。
>
>    怎么进行选型，什么场景下选用合适的分布式事务框架处理？
>
> 6. ##### **17.9 怎么进行选型，什么场景下选用合适的分布式事务框架处理？**
>
>    **Xa模式****：**需要强一致，这种使用的比较少，性能很差，比如有一些转账业务，需要强一致，可以使用
>
>    **At模式****：**如果项目中只是新增业务，这个可以用xa模式处理，因为回滚只要删除这条记录就可以了，不会有丢失更新需要人工干预
>
>    **Tcc模式****：** 假如项目中有对数据库某一个字段进行频繁的增加或者减少操作可以用tcc模式，因为这种模式是预留资源，做到数据隔离，不会有丢失更新的风险
>
>    本地消息表（半事务消息）其他微服务实时性要求不高，比如退钱业务。
>
>    ##### **17.10 让你去设计一个分布式框架要考虑哪些因素？**
>
>    首先要定义事务的边界，知道哪些事务需要假如分布式事务管理，第二个就是要有一个全局的事务管理器，他能发起所有事务的统一提交或者回滚，然后要做好日志的记录，这样方便最终问题，还要做好超时处理机制

### 18. **开发支付对账功能，后期采用redis set集合优化对账逻辑解决数据库连接过多问题。（重要）**[xxl-job](https://www.bilibili.com/video/BV1824y1G7vT/?spm_id_from=333.337.search-card.all.click)

**项目中有没有用到数据库的本地事务？（重要）**

> 有，比如用户充值余额支付完成后，支付宝回调我们这边接口，我们需要保证修改支付订单表，商品订单表以及给用户增加余额要保证在一个事务里面。还有用户余额退款，修改支付订单表，商品订单表以及给用户增加余额要保证在一个事务里面。
>
> 在冻结和解冻余额的时候也用到了数据库事务，这个操作不仅仅只修改余额这个字段的值，还需要新增一条冻结详细记录信息。
>
> @Transactional八股文要背一下，事务失效场景，事务注解有哪些属性可以设置，默认是事务隔离级别，事务的传播行为等，传播行为容易出场景题。

##### **你们对账怎么做的？**

> ***\*我们公司先对总账，如果总账有问题再对明细\*******\*。\****我们是通过定时任务xxl-job每天上午九点下载第三方支付平台***\*前一天\****的账单***\*入库\****再和我们数据库支付订单表进行对账，首先我们数据库有一张批次表，记录每天对账的批次。然后调用支付宝下载账单接口，这个接口返回的一个URL，我们还需要通过URLConnection conn = url.openConnection()去下载该账单，返回的是一个压缩文件，我们需要进行解压，解压后会有两个csv文件，一个是账单明细，一个是总账，账单明细对应的就是每一条支付成功或者退款成功的数据，总账文件只有总的支付成功金额和退款金额。
>
> ***\*然后我们把昨天的总账数据和明细数据分别读取插入数据库支付宝总账表和支付宝账单明细表(微信对账也有这两张表)\****，然后开启对账逻辑，（其实对账就是对比两张表差异数据（缺失的数据或者金额错误），所以要互相进行比对）。
>
> 先正向对账，将昨天我们数据库所有已支付的支付订单支付的金额和退款的金额分别进行累加返回昨天退款和支付总金额，然后和支付宝总账数据进行对比，如果一样则昨天所有账单对账完成（对总账），如果总账对账不一样，我们会对昨天所有支付成功的支付订单和支付宝订单表的支付订单进行明细对比，找出两个表中差异数据，或者金额不一致的订单，把这些对账差异数据插入到对账差异表中，并同时将这些数据以邮件的方式推送给运营和产品经理。***\*刚开始这块对账我是\*******\*纯用数据库做的\****用了两个for循环先查出一个表的账单数据，然后再通过这笔账单的支付订单号查询另一个表进行数据比对，这样数据量少的时候可能没太大问题，当时每日的订单量在200左右没有太大问题。
>
> 但是后期订单量上几万后明细有性能问题，后面我就想到了用redis进行优化，redis的set集合可以取两个集合的差集，为了防止存入redis数据量太多，我只把支付宝订单表和支付订单表的支付订单号和金额通过逗号进行拼接，然后存入redis set集合，得到两个redis set集合，key1 ，key2，调用sdiff方法就可以取出两个集合的差集，sdiff key1 key2 表示key2中没有key1的数据，sdiff key2 key1 表示key1中没有key2的数据，所以需要调用sdiff两次，正反对一遍。例如A集合 a b c,B集合c d e，那么sdiff A， B返回 a，b。sdiff
>
> B A 返回 d，e。

