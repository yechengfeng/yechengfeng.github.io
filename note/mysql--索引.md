> - 什么是索引
>
> - 索引的分类
>
>   - 按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。
>
>   - 按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。
>
>   - 按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。
>
>   - 按「字段个数」分类：单列索引、联合索引。
>
> - 在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：
>
>   - 如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
>
>   - 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
>
>   - 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
>
> - 其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。创建的主键索引和二级索引默认使用的是 B+Tree 索引
>
>   -  B+Tree 索引
>
>     - B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。（图中叶子节点应该 是双向列表）
>     - ![img](https://leslieyedoc.oss-cn-shanghai.aliyuncs.com/img/20250915-112704-8209378_e9846816-fe8e-45a2-dc8e-88a677a034fb.png)
>
>     - B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。
>
>   - 通过二级索引查询商品数据的过程
>
>     - 主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：
>
>       - 主键索引的 B+Tree  的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
>
>       - 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。
>
>     - 所以这地方涉及到一些回表,锁引下推，索引覆盖的概念
>
>   - 为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？
>
>     - 1、B+Tree vs B Tree
>
>       - B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。
>
>       - 另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。
>
>     - 2、B+Tree vs 二叉树
>       - 二叉树的高度无意更高，查询的IO更多
>
>     - 3、B+Tree vs Hash
>       - Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。
>
>   - 按物理存储分类 （从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引））
>
>     - 从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。
>
>     - 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。
>       - 所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。
>
>   - 按字段特性分类
>
>     - 从字段特性的角度来看，索引分为
>
>       - 主键索引、 primary key
>         - 主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。
>
>       - 唯一索引、unique key
>         - 唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。
>
>       - 普通索引、
>         - 普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。
>
>       - 前缀索引。
>         - 前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。
>
>   - 按字段个数分类
>
>     - 建立在单列上的索引称为单列索引，比如主键索引；
>
>     - 建立在多列上的索引称为联合索引；
>
>       - 因此，使用联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。
>
>       - 联合索引范围查询
>
>       - 索引下推
>
>       - 索引区分度
>
>         
>
>         - 因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是"30%"）很高的时候，它一般会忽略索引，进行全表扫描。
>
>       - 联合索引进行排序
>
>         - select * from order where status = 1 order by create_time desc
>
>         - 因为在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 Using filesort。所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率。
>
> - 什么时候需要 / 不需要创建索引？
>
>   - 缺点
>
>     - 需要占用物理空间，数量越大，占用空间越大；
>
>     - 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；
>
>     - 会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。
>
>   - 什么时候适用索引？
>
>     - 字段有唯一性限制的，比如商品编码；
>
>     - 经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段， 可以建立联合素引。
>
>     - 经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。
>
>   - 什么时候不需要创建索引？
>
>     -  WHERE 条件， GROUP BY，ORDER BY 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
>
>     - 字段中存在大量重复数据，不需要创建素引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽路索引，进行全表扫描。
>
>     - 表数据太少的时候，不需要创建索引；
>
>     - 经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立素引，因为索引字段频繁修改，由手要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。
>
>   - 有什么优化索引的方法？
>
>     - 前缀索引优化；
>       - 使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。
>
>     - 缺点
>
>       - order by 就无法使用前缀索引；
>
>       - 无法把前缀索引用作覆盖索引；
>
>     - 覆盖索引优化；
>
>       - 覆盖索引是指 SQL中query的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些素引，从二级索引中查询得到记录，而不需要通过聚族索引查询获得，可以避免回表的操作。
>
>       - 假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？
>
>       - 我们可以建立一个联合素引，即「商品ID、名称、价格」作为一个联合素引。如果索弓！中存在这些数据， 查询将不会再次检索主键素引，从而避免回表。
>
>       - 所以，使用覆盖素引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的IO操作。
>
>     - 主键索引最好是自增的；
>       - InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂，页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率
>
>     - 索引最好设置为 NOT NULL
>
>       - 第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。
>
>       - 第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式中至少会用 1 字节空间存储 NULL 值列表
>
>     - 防止索引失效；
>
>       - 对索引使用左或者左右模糊匹配
>
>       - 对索引使用函数
>
>       - 对索引进行表达式计算
>
>       - 对索引隐式类型转换
>
>       - 联合索引非最左匹配
>
>       - WHERE 子句中的 OR
>
> - MYSQL索引
>
>   - 建立索引
>
>     - 表的主键、外键必须有索引；
>
>     - 数据量超过300的表应该有索引；
>
>     - 经常与其他表进行连接的表，在连接字段上应该建立索引；
>
>     - 经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；
>
>     - 索引应该建在选择性高的字段上；
>
>     - 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；
>
>     - 频繁进行数据操作的表，不要建立太多的索引；
>
>   - 索引失效
>
>     - 字符串不加单引号
>
>     - 将要使用的索引列不是复合索引列表中的第一部分，则不会使用索引
>
>     - 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如
>       - select id from t where num is null
>
>     - 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。
>
>     - 应尽量避免在 where 子句中使用 or 来连接条件 (用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到)，否则将导致引擎放弃使用索引而进行全表扫描，
>
>     - in 和 not in 也要慎用，因为IN会使系统无法使用索引,而只能直接搜索表中的数据。
>
>     - 对于连续的数值，能用 between 就不要用 in 了
>
>     - 尽量避免在索引过的字符数据中，使用非打头字母%搜索。这也使得引擎无法利用索引
>
>     - 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描
>
>     - 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描
>
>     - 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引
>
>   - 共享锁，排他锁
>
>     - InnoDB普通 select 语句默认不加锁(快照读，MYISAM会加锁)，而CUD操作默认加排他锁
>
>     - MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处，相信也是耳熟能详：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC。
>
>     - 多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读.MVCC 在语境中倾向于 “对多行数据打快照造平行宇宙”，然而 CAS 一般只是保护单行数据而已
>
>     - 在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。
>
>     - SELECT … LOCK IN SHARE MODE ：共享锁(S锁, share locks)。其他事务可以读取数据，但不能对该数据进行修改，直到所有的共享锁被释放。
>
>     - SELECT … FOR UPDATE：排他锁(X锁, exclusive locks)。如果事务对数据加上排他锁之后，则其他事务不能对该数据加任何的锁。获取排他锁的事务既能读取数据，也能修改数据。
>
>     - InnoDB默认隔离级别 可重复读(Repeated Read)
>
>     - 查询字段未加索引（主键索引、普通索引等）时，使用表锁
>
>     - InnoDB行级锁基于索引实现
>
>     - 索引数据重复率太高会导致全表扫描：当表中索引字段数据重复率太高，则MySQL可能会忽略索引，进行全表扫描，此时使用表锁。可使用 force index 强制使用索引。
>
>   - 隔离级别
>
>     - Read Uncommitted（读取未提交内容）: 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。
>
>     - Read Committed（读取提交内容）:  这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。
>
>     - Repeatable Read（可重读）: 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。
>
>     - Serializable（可串行化): 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争.
>
>   - Mybatis缓存
>
>     - https://open.alipay.com/portal/forum/post/172301012
>
>     - 一级缓存的作用域是同一个SqlSession，在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。Mybatis默认开启一级缓存。
>
>     - 二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession去操作数据库得到数据会存在二级缓存区域，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认没有开启二级缓存需要在setting全局参数中配置开启二级缓存
>
>   - 数据库数据不一致的原因
>
>     - 数据冗余
>       - 如果数据库中存在冗余数据，比如两张表中都存储了用户的地址，在用户的地址发生改变时，如果只更新了一张表中的数据，那么这两张表中就有了不一致的数据。
>
>     - 并发控制不当
>       - 比如某个订票系统中，两个用户在同一时间订同一张票，如果并发控制不当，可能会导致一张票被两个用户预订的情况。当然这也与元数据的设计有关。
>
>     - 故障和错误
>       - 如果软硬件发生故障造成数据丢失等情况，也可能引起数据不一致的情况。因此我们需要提供数据库维护和数据恢复的一些措施。

#### 从数据页的角度看B+树

​	https://xiaolincoding.com/mysql/index/page.html#innodb-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84

> - InnoDB 是如何存储数据的？
>
>   - InnoDB 的数据是按「数据页」为单位来读写的
>
>   - InnoDB 数据页的默认大小是 16KB
>
>     
>
>     - 数据页包含七个部分
>
>       - 文件头38bytes
>
>       - 页头56bytes
>
>       - 行记录
>
>         - 最大最小记录
>
>         - 用户记录
>
>       - 空闲空间
>
>       - 页目录
>
>       - 文件尾
>
>     - 在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，如下图所示：
>
>       
>
>       - 采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。
>
>       - 数据页中的记录按照「主键」顺序组成单向链表，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。
>
>   - B+ 树是如何进行查询的？
>
>   - 聚簇索引和二级索引
>     - 如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。
>
>   - 总结
>
>     - InnoDB 的数据是按「数据页」为单位来读写的，默认数据页大小为 16 KB。每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。
>
>     - 数据页内包含用户记录，每个记录之间用单向链表的方式组织起来，为了加快在数据页内高效查询记录，设计了一个页目录，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。
>
>     - 为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。
>
>     - 在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」。