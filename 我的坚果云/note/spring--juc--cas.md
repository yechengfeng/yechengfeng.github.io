- 什么是CAS

  - CAS（Compare-And-Swap）是比较并交换的意思，它是一条 CPU 并发原语，用于判断内存中某个值是否为预期值，如果是则更改为新的值，这个过程是原子的。

  - 更新一个变量的时候，只有当变量的预期值 A 和内存地址 V 中的实际值相同时，才会将内存地址 V 对应的值修改为 B，这整个操作就是CAS。

- CAS 基本原理

  - 在 Intel 的 CPU 中，使用 cmpxchg 指令。是一条CPU原语，所以可以保证原子性

- 3. CAS 在 Java 语言中的应用

  - 在 Java 编程中我们通常不会直接使用到 CAS，都是通过 JDK 封装好的并发工具类来间接使用的，这些并发工具类都在java.util.concurrent包中。比如说 AtomicInteger 类就可以解决 i++ 非原子性问题，通过查看源码可以发现主要是靠 volatile 关键字和 CAS 操作来实现，具体原理和源码分析后面的文章会展开分析。
  - ![img](https://leslieyedoc.oss-cn-shanghai.aliyuncs.com/img/20250927-125215-8209378_a243d384-f00f-45cf-9965-c80f93576801.png)

- CAS 的问题（CAS 不是万能的，也有很多问题。）非常重要，使用一定要考虑场景，没有东西是万能的！！

  - 4.1. 典型 ABA 问题
    - 从 JDK 1.5 开始提供了AtomicStampedReference类，这个类的 compareAndSe 方法首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志`，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

  - 4.2. 自旋开销问题（我认为通常应该用在锁竞争不是特别激烈的时候，可以提高效率，否则CPU空转，反而效果不好）
    - CAS 出现冲突后就会开始自旋操作，如果资源竞争非常激烈，自旋长时间不能成功就会给 CPU 带来非常大的开销。
      - 解决方案：可以考虑限制自旋的次数，避免过度消耗 CPU；另外还可以考虑延迟执行。

  - 4.3. 只能保证单个变量的原子性
    - 当对一个共享变量执行操作时，可以使用 CAS 来保证原子性，但是如果要对多个共享变量进行操作时，CAS 是无法保证原子性的，比如需要将 i 和 j 同时加 1：

- AtomicInterger原理

  - 变量大致可以分为局部变量和共享变量，局部变量对于 JVM 来说是栈空间，栈是线程私有的是非共享的，那自然也是内存安全的；共享变量对于 JVM 来说一般是存在于堆上，堆上的东西是所有线程共享的，如果不加任何限制自然是不安全的。

  - 什么是 Atomic？

    - Atomic 包下的原子操作类有很多，可以大致分为四种类型：

      - 原子操作基本类型

      - 原子操作数组类型

      - 原子操作引用类型

      - 原子操作更新属性

  - 实现一个计数器

  - AtomicLong 和 LongAdder 谁更牛？

    - Java 在 jdk1.8版本 引入了 LongAdder 类，与 AtomicLong 一样可以实现加、减、递增、递减等线程安全操作，但是在高并发竞争非常激烈的场景下 LongAdder 的效率更胜一筹。

    - longAdder 实现原理

      - https://www.cnblogs.com/shoshana-kong/p/17004806.html

      - https://juejin.cn/post/6922770632358756359