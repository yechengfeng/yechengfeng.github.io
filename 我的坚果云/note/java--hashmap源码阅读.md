> - Hash-Map
>
>   - Key-value的键值 对的集合，每一个键值对也叫做Entry 
>
> - 数组
>
>   - 由相同类型的集合组成的结构，分配一块连续的内存来存储，利用元素的索引可以计算出该元素对应的存储地址
>
> - 链表
>
>   - 每一个节点存储下一个节点的指针，不是一定要顺序存储，插入的时候可以达到O(1)的复杂度，但是查找需要O(n)
>
> - String 的Hash算法
>
>   - HashCode实现  31 Hash分布可以减少Hash冲突，散列效果最好
>
> - 如何解决Hash冲突
>
>   - 链地址法
>
>     - 对于不同的关键字可能通过散列函数映射到同一个地址，为了避免Hash冲突，可以把所有的同义词存储在一个线性链表中，这个线性表由其散列地址唯一标识
>
>     - 1.8之后如果数组的容量大于64并且链表长度大于8，那么就会转链表为红黑树。红黑树的查询效率是一个稳定的log(On)
>
> - 源码分析
>
>   
>
>   -  取key的Hashcode的值，然后右移16位，然后异或运算。 
>     - 如此设计让高16位和低16位都参与运算，异或可以让结果分布更均匀
>
>   - 扩容源码 有点复杂
>
>   - get方法源码
>
> - HashMap注意点 
>
>   - key最好使用不可变对象，否则对象改变时候，重新计算Hashcode值会与之前的不一样，导致错误
>
> - HashMap 的容量设计为 2 的 n 次幂 主要是为了优化计算桶下标（索引位置）的效率和优化扩容时的元素迁移。这是 HashMap 实现中的一个关键设计决策，主要基于以下几个原因：
>
>   - \1. 高效计算桶下标：hash & (length - 1) 代替取模
>
>   - \2. 优化扩容时的元素迁移
>
>   - \3. 降低哈希冲突的概率（辅助作用）