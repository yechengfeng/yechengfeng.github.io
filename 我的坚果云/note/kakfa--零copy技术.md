[https://mp.weixin.qq.com/s/XmGobf693GYNT_3h6ZwsTg](https://mp.weixin.qq.com/s/XmGobf693GYNT_3h6ZwsTg)

> 0-copy（零拷贝，Zero-Copy）技术是一种 **优化数据传输的机制**，它的核心目标是 **减少甚至消除用户态与内核态之间的数据拷贝**，从而降低 **CPU开销**、**内存带宽消耗**，提高 **I/O性能**。

在传统的 I/O 流程里，比如应用程序从磁盘读取一个文件然后通过网络发送，通常会发生 **多次数据拷贝**：

1. **磁盘 → 内核缓冲区**（DMA拷贝，硬件执行）
2. **内核缓冲区 → 用户空间缓冲区**（CPU拷贝）
3. **用户缓冲区 → 内核 socket 缓冲区**（CPU拷贝）
4. **socket 缓冲区 → 网卡**（DMA拷贝）

这种方式在处理大文件传输时，**CPU 大量时间耗在拷贝上，而不是业务逻辑**。

## 🔹0-copy 的思路

零拷贝技术的目标就是 **绕过用户态的中间拷贝步骤**，让数据直接在 **内核缓冲区和硬件之间传输**，避免多余的 CPU 拷贝。

以 Linux 下的 `sendfile` 为例，优化后的流程：

1. **磁盘 → 内核页缓存**（DMA拷贝）
2. **内核页缓存 → socket 缓冲区**（仅拷贝指针/元数据，不拷贝实际数据）
3. **socket 缓冲区 → 网卡**（DMA拷贝）

这样就把原本的 **4 次拷贝减少为 2 次拷贝**，CPU 只负责数据描述信息的转移，大幅提升了性能

## 🔹Kafka 的 0-copy 做法

Kafka 借助 **Linux 提供的 `sendfile` 系统调用** 来实现零拷贝。

### Kafka 使用 sendfile（零拷贝）

1. 磁盘 → 内核页缓存（DMA 拷贝）
2. 内核页缓存 → socket buffer（仅元数据拷贝，不拷贝数据本身）
3. socket buffer → 网卡（DMA 拷贝）

Kafka 的 broker 在把 **消息从磁盘文件发送到消费者** 时，直接使用 `FileChannel.transferTo()`（底层调用 `sendfile`），把文件内容直接推到网络 socket，不用先拷到 JVM 堆内存。

## 🔹Kafka 的优化点

除了 0-copy，Kafka 还做了几件事配合：

1. **顺序写磁盘**
   - Kafka 写入消息时只在 log segment 末尾追加，几乎是顺序写，非常高效。
2. **页缓存（Page Cache）利用**
   - Kafka 不自己管理磁盘页，而是充分依赖 OS 的页缓存，减少磁盘 I/O。
3. **批量处理**
   - Kafka 将消息打包批量写入和发送，减少系统调用次数。
4. **压缩（可选）**
   - 在批量发送时压缩数据，降低网络带宽消耗。

主流的0copy技术还有MMAP（内存映射）

> mmap是Linux提供的一种内存映射文件的机制，它实现了将内核中读缓冲区地址与用户空间缓冲区地址进行映射，从而实现内核缓冲区与用户缓冲区的共享。这样就减少了一次用户态和内核态的CPU拷贝，但是在内核空间内仍然有一次CPU拷贝。























