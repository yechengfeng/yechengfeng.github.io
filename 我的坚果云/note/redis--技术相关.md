- ### Redis内存淘汰策略

  - 如何配置最大内存？

    - maxmemory 1024mb 

      - 设置Redis最大占用内存大小为1024M

      - 注意：maxmemory默认配置为0，在64位操作系统下redis最大内存为操作系统剩余内存，在32位操作系统下redis最大内存为3GB。

    - Redis支持运行时通过命令动态修改内存大小：

      - config set maxmemory 200mb

      - config get maxmemory 

  - 淘汰策略的分类

    - **noeviction 默认策略，写请求直接返回错误**

    - **allkeys-lru**
      - lru(less recently used), 最近最少使用。从所有的key中使用近似LRU算法进行淘汰。

    - **volatile-lru**
      - lru(less recently used), 最近最少使用。从设置了过期时间的key中使用近似LRU算法进行淘汰。

    - **allkeys-random**
      - 从所有的key中随机淘汰。

    - **volatile-random**
      - 从设置了过期时间的key中随机淘汰。

    - **volatile-ttl**
      - ttl(time to live)，在设置了过期时间的key中根据key的过期时间进行淘汰，越早过期的越优先被淘汰。

    - **allkeys-lfu**
      - lfu(Least Frequently Used)，最少使用频率。从所有的key中使用近似LFU算法进行淘汰。从Redis4.0开始支持。

    - **volatile-lfu**
      - lfu(Least Frequently Used)，最少使用频率。从设置了过期时间的key中使用近似LFU算法进行淘汰。从Redis4.0开始支持。

    - **注意：当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有设置过期的key可以被淘汰，则和noeviction一样返回错误。**

  - **Redis内存失效策略**

    - Redis的key一般会设置一个过期时间，等过期之后Redis会从内存清除这些key，如何清除？一般有三种策略：定时清除、惰性清除、定时扫描清除。

    - 定时清除（主动）

      - 每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。

      - 该策略可以立即清除过期的数据，对内存很友好，但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。

    - 惰性清除（被动）

      - 当key过期之后不会立即从内存清除，只有当访问一个key时，才会判断该key是否已过期，如果过期则清除并返回空。

      - 该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。

    - 定期扫描清除（主动）
      - 每隔一定的时间会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。

    - Redis中同时使用了惰性清除和定期扫描清除两种策略。

  - #### 缓存异常场景

    - **缓存穿透**

      - 缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍，然后返回空。

      - 缓存穿透常用的解决方案

        - （1）布隆过滤器（推荐）

          - 爬虫系统url去重

          - 垃圾邮件过滤

          - 黑名单

        - （2）返回空对象

    - **缓存击穿**

      - 缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

        - 常用的解决方案

          - 使用互斥锁（mutex key）一条线程先写入，其他线程等待

          - 热点数据永不过期

    - **缓存雪崩**

      - 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，请求直接落到数据库上，引起数据库压力过大甚至宕机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

        - 解决方案

        - 1）均匀过期
          - 设置不同的过期时间，让缓存失效的时间点尽量均匀。通常可以为有效期增加随机值或者统一规划有效期。

        - （2）加互斥锁
          - 跟缓存击穿解决思路一致，同一时间只让一个线程构建缓存，其他线程阻塞排队。

        - （3）缓存永不过期
          - 跟缓存击穿解决思路一致，缓存在物理上永远不过期，用一个异步的线程更新缓存。

        - （4）双层缓存策略

        - 使用主备两层缓存：

          - 主缓存：有效期按照经验值设置，设置为主读取的缓存，主缓存失效后从数据库加载最新值。

          - 备份缓存：有效期长，获取锁失败时读取的缓存，主缓存更新时需要同步更新备份缓存。

    - **缓存预热**

      - 什么是缓存预热？

      - 缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统，这样就可以避免在用户请求的时候，先查询数据库，然后再将数据回写到缓存。

      - 如果不进行预热， 那么 Redis 初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。

    - **缓存降级**

      - 缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。

      - 在项目实战中通常会将部分热点数据缓存到服务的内存中，这样一旦缓存出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。

      - 降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。

- ### 高可用架构

  - Replication（主从复制）

    - 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。

    - 主从复制实现原理

      - 主从复制过程主要可以分为3个阶段：连接建立阶段、数据同步阶段、命令传播阶段。

      - 连接建立阶段（该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备。）

        - 步骤1：保存主节点信息
          - slaveof命令是异步的，在从节点上执行slaveof命令，从节点立即向客户端返回ok，从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息。

        - 步骤2：建立socket连接

        - 步骤3：发送ping命令

          - 从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。

          - 从节点发送ping命令后，可能出现3种情况：

          - （1）返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。

          - （2）超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。

          - （3）返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。

        - 步骤4：身份验证
          - 如果从节点中设置了masterauth选项

        - 步骤5：发送从节点端口信息

      - 数据同步阶段

      - 命令传播阶段

        - 数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。

        - 需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。

  - Sentinel（哨兵模式）

    - 哨兵模式的主要作用在于它能够自动完成故障发现和故障转移，并通知客户端，从而实现高可用。哨兵模式通常由一组 Sentinel 节点和一组（或多组）主从复制节点组成。

    - 心跳机制

      - （1）Sentinel与Redis Node
        - Redis Sentinel 是一个特殊的 Redis 节点。在哨兵模式创建时，需要通过配置指定 Sentinel 与 Redis Master Node 之间的关系，然后 Sentinel 会从主节点上获取所有从节点的信息，之后 Sentinel 会定时向主节点和从节点发送 info 命令获取其拓扑结构和状态信息。

      - （2）Sentinel与Sentinel
        - 基于 Redis 的订阅发布功能， 每个 Sentinel 节点会向主节点的 sentinel：hello 频道上发送该 Sentinel 节点对于主节点的判断以及当前 Sentinel 节点的信息 ，同时每个 Sentinel 节点也会订阅该频道， 来获取其他 Sentinel 节点的信息以及它们对主节点的判断。

      - 通过以上两步所有的 Sentinel 节点以及它们与所有的 Redis 节点之间都已经彼此感知到，之后每个 Sentinel 节点会向主节点、从节点、以及其余 Sentinel 节点定时发送 ping 命令作为心跳检测， 来确认这些节点是否可达。

    - 故障转移

  - Cluster（集群）

    - Redis-Cluster采用无中心结构，每个节点都保存数据，节点之间互相连接从而知道整个集群状态。如图所示Cluster模式其实就是多个主从复制的结构组合起来的，每一个主从复制结构可以看成一个节点，那么上面的Cluster集群中就有三个节点。
    - <img src="https://leslieyedoc.oss-cn-shanghai.aliyuncs.com/img/20250909-153605-8209378_fc380177-3db0-4558-aee8-867bb27f13d1.png" alt="img" style="zoom:67%;float=left" />

    - Redis集群TCP端口

      - 每个Redis集群节点都需要开启两个TCP监听端口，一个用于给客户端提供普通的Redis服务，常见为6379，另外一个用于集群间通信服务，一般为在普通端口基础上偏移10000如16379。

      - 第二个端口用于集群总线，即使用二进制协议的节点到节点的通信通道。节点使用集群总线进行故障检测，配置更新，故障转移授权等。客户端永远不应尝试与集群总线端口通信，但始终使用正常的Redis命令端口，但请确保在防火墙中打开两个端口，否则Redis集群节点将无法通信。