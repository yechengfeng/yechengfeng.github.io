[https://sentinelguard.io/zh-cn/docs/introduction.html](https://sentinelguard.io/zh-cn/docs/introduction.html)

- Guava和 RateLimiter 限 流

  - 任何应用和模块组件都有 一定的访问速率上限，如果请求速率突破了这个上限，不但 多余的请求无法处理，甚至会压垮系统使所有的请求均无法有效处理。因此，对请求进行限流是非常必要的。Ratel imiter 正是这么一款限流工具。

  - 一般化的限流算法有两种:**漏桶算法**和**令牌桶算法**。

    - **漏桶算法的基本思想是:利用一个缓存区， 当有请求进入系统时，无论请求的速率如 何，都先在缓存区内保存，然后以固定的流速流出缓存区进行处理**

    - **令牌桶算法是一种反向的漏桶算法。在令牌桶算法中，桶中存放的不再是请求，而是 令牌。处理程序只有拿到令牌后，才能对请求进行处理。如果没有令牌， 那么处理程序要 么丢弃请求，要么等待可用的令牌。为了限制流速，该算法在每个单位时间产生 一定量的 令 牌 存 入 桶 中 。 比 如 ， 要 限 定 应 用 每 秒 只 能 处 理 1 个 请 求， 那 么 令 牌 桶 就 会 每 秒 产 生 1 个 令牌。通常，桶的容量是有限的，比如，当令牌没有被消耗掉时，只能累计有限单位时间 内的令牌数 量。**

  - API

    - ```java
      RateLimiter.create(100);限流100permits/seconds
      
      rateLimiter.acquire()阻塞直到获取令牌
      
      rateLimiter.tryAcquire()非阻塞获取令牌
      
      tryAcquire(time,TimeUnit);带时间的
      ```

  - 适用于单机限流，如果分布式限流需要结合redis或者专业限流组件 如sentinel实现集群限流

