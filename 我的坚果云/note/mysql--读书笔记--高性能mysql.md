> - 1.1 逻辑架构
>
>   - 客户端 ->
>
>   - ->services
>     - 连接器--》查询缓存->解析器->优化器
>
>   - ->存储引擎
>
> - 1.1.1 链接管理和安全性
>
> - 1.1.2 优化和执行
>
>   - mysql会解析查询，创建内部的数据结构（解析树）然后对其优化，包括重写查询，决定表的读取顺序，选择合适的索引，用户可以更具关键字提示优化器，影响他的决策过程
>
>   - 查询缓存在mysql8.0已经禁止
>
>     - 查询缓存的一个问题是收到单个互斥锁的保护，导致互斥锁争用，5.6也是默认关闭查询缓存的 query_cache_type =0
>
>     - 查询缓存使用一个全局锁（query_cache_lock）来管理缓存操作（检查、存储、失效）。在高并发环境下，这个全局锁成为巨大的瓶颈。即使查询本身很快，获取和释放这个锁的开销也会导致严重的性能下降。写操作（INSERT, UPDATE, DELETE, DDL）需要使涉及到的表的所有缓存查询失效（invalidate）。这个失效操作也需要持有全局锁，阻塞所有其他缓存操作（读和写），在高并发写或读写混合场景下，这会导致显著的延迟。
>
> - 1.2并发控制
>
>   - 读写锁
>
>   - 锁粒度
>
>     - 表锁
>
>       - mysql最基本的锁策略，开销最小的策略
>
>       - 一个用户在对表进行写操作时候，需要先获取锁，会祖册其他用户对该表所有的读写操作，没有写锁时候，其他读取用户才可以获取锁，写锁的优先级高于读锁，因此 写锁请求可能会被插入到读锁队列前面
>
>     - 行级锁（row lock）
>
>       - 行级锁可以最大程度支持并发处理，但是带来了最大的锁开销
>
>       - 行级锁只在存储引擎层实现，而mysql服务器没有实现，服务器层完全不了解存储引擎中的锁实现
>
> - 1.3事务
>
>   - 如何开启事务
>
>     - start Transaction；sql; commit;
>
>     - acid 原子性，一致性 ，隔离性，持久性
>
>     - 1.3.1隔离级别 
>
>       - 较低级别的隔离通常可以执行更高的并发，系统的开销也最小
>
>       - 读未提交
>         - 事务中的修改，即使没有提交，对其他事务也都是可见的，事务可以读取为提交的数据，也被称为脏读，从性能上，不会比其他的级别好太多，但是缺点很大，所以一般不会使用
>
>       - 读已经提交
>         - 一个事物提交之前，所做的修改对其他事务都是不可见的，
>
>       - 可重复读
>         - 保证了同一个事务在多次读取同样的记录的结果是一致的，但是还是无法解决幻读问题。幻读就是某个事务在读取某个范围记录的时候，令一个事务在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时候，产生了幻行。Inodb 通过多版本并发控制解决了幻读的问题
>
>       - 串行化
>         - 强制事务串行执行，几乎不用
>
>     - 1.3.2死锁
>
>       - 死锁是俩个或者多个事务在同一个资源上相互占用，并且请求锁定对方占用的资源，从而导致恶性循环的现象
>
>       - 当俩个事务同时锁定同一个资源的时候，也会产生死锁
>         - Inodb 存储引擎，实现了各种锁检测和死锁超时机制，即可反回一个错误
>           - innodb处理死锁的方法是将持有最少行级排他锁的事务进行回滚（相对简单的死锁回滚算法）
>
>     - 1.3.3 事务日志
>
>       - 事务日志可以帮助提高事务的效率，使用事务日志，存储引擎修改标的数据，只需要修改内存的copy，再把修改行为记录到持久在硬盘上的事务日志中，而不需要每次都将修改的数据本身持久化到磁盘，事务日志采用的是追加的方式，因此，写日志的操作是磁盘上一小块区域内的顺序IO,而不像随机IO需要在磁盘的多个地方移动磁头，事务日志持久以后，内存中的数据慢慢的刷回磁盘，也就是我们说的预写式日志。修改数据需要写入俩次磁盘。
>         - 这个很深刻 学习到了
>
>       - 如果修改的数据已经记录到日志并且持久化，数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启的时候可以自动恢复这些数据。
>
>     - 1.3.4 mysql中的事务
>
>       - 自动提交
>
>         - mysql默认采用自动提交的模式，也就是说 不如不是显式的开始一个事务，每个查询都会被当做一个事务进行提交操作，在当前连接中，可以通过设置 AUTOCOMMIT变量来弃用或者禁用自动提交模式
>
>           - set AUTOCOMMIT =1
>
>           - 当=0时候，所有的查询都是在一个事务中，知道显式的执行 commit或者rollback回滚，该事务结束。
>
>       - 事务中混合使用存储引擎
>         - mysql服务器不管理事务，事务是下层的存储引擎实现的，所以在同一个事务中，使用多种存储引擎是不可靠的，如果在事务中混合使用了事务性和非事务性表，如果需要回滚，就会出现问题。所以为每张表选择合适的存储引擎非常重要。  无脑选择innoDB，如果混合使用，那么有事务的时候，可能产生问题
>
>       - 隐式和显式锁定
>
>         - innodb采用的是俩阶段锁定协议
>           - 两阶段锁定协议（Two-Phase Locking, 2PL）是数据库管理系统（DBMS）中用于保证事务可串行化（Serializable）的一种经典并发控制协议。它的核心思想是将事务对数据项的加锁和解锁操作划分为两个不可重叠的阶段，从而避免事务间的冲突导致数据不一致。
>             - 我的理解就是 就是在事务开始之后，事务只能加锁，不能释放锁；所有的锁必须在事务提交之后才可以释放 。在释放锁的时候，不能加锁
>
>         - mysql也支持lock tables ; unlock tables 这是服务器层面的实行，和存储引擎无关。如果用innodb 没必要用这些显示的语句，会严重影响性能，innodb的行级锁更好
>
>   - 1.4 多版本并发控制
>
>     - MVCC是行级锁的一个变种，但是他在很多情况下避免了加锁操作，所以开销更低。
>
>     - 工作原理是使用数据在某个时间点的快照来实现，也意味着不同的事务在同一时间看到同一张表的不同数据， 也意味着无论事务运行多长时间，都可以看到数据的一致视图
>
>       > ![img](https://leslieyedoc.oss-cn-shanghai.aliyuncs.com/img/20250909-162547-20250909-162512-8209378_7445e9c0-8bd5-46c8-9288-79f79e2af393.png)
>
>     - InnoDB通过为每个事务在启动时分配一个事务ID来实现MVCC。该ID在事务首次读取任何数据时分配。在该事务中修改记录时，将向Undo日志写入一条说明如何恢复该更改的Undo记录，并且事务的回滚指针指向该Undo日志记录。这就是事务如何在需要时执行回滚的方法。
>
>     - 当不同的会话读取聚簇主键索引记录时，InnoDB会将该记录的事务ID与该会话的读取视图进行比较。如果当前状态下的记录不应可见（更改它的事务尚未提交），那么Undo日志记录将被跟踪并应用，直到会话达到一个符合可见条件的事务ID。这个过程可以一直循环到完全删除这一行的Undo记录，然后向读取视图发出这一行不存在的信号。
>
>     - 事务中的记录可以通过在记录的“info flags”中设置“deleted”位来删除。这在Undo日志中也被作为“删除标记”进行跟踪。值得注意的是，所有Undo日志写入也都会写入redo日志，因为undo日志写入是服务器崩溃恢复的过程一部分，而且是事务性的
>
>     - MVCC仅适用于重复读，和读未提交隔离界别
>
>     - https://zhuanlan.zhihu.com/p/451007506
>
>   - 复制
>     - 对于生产环境中运行的数据，都应该使用复制并且至少有三个以上的副本，理想情况下应该分布在不同的地区用于灾难恢复计划
>
>   - 数据文件结构
>     - 8.0版本中 mysql将表的元数据重新设计成一种数据字段，包含在表的.idb文件中 
>
>   - INnoDB引擎
>
>     - json文档支持
>
>       - 5.7版本被引入了，优化了存储，运行快速读取，旧版本只能用blob类型来处理
>
>       - 8.0版本进一步改进了增加了json数组上定义多值索引的能力
>
>     - 数据字典的变化
>       - 8.0删除了基于文件的表元数据存储，将其转移到了使用innodb表存储的数据字典中
>
>     - 原子DDl
>
> - 总结
>
>   - mysql拥有分层的架构，上层是服务器级别的服务和查询执行层，下层是存储引擎，mysql通过API来和存储引擎交互需要处理的数据