CPU

- top

文件IO

> - ls
> - stat
>   - 查看文件详情
> - ln
>   - 软硬连接

文本操作命令

> cat    more less head tail sort uniq

日志

> - /var/log/message 系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一
> - /var/log/secure 与安全相关的日志信息
> - /var/log/maillog 与邮件相关的日志信息
> - /var/log/cron 与定时任务相关的日志信息
> - /var/log/spooler 与UUCP和news设备相关的日志信息
> - /var/log/boot.log 守护进程启动和停止相关的日志消息
> - /var/log/wtmp 该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件

进程

> - ps –ef/-aux
> - lsof 进程打开的文件、端口
> - AWK/SED

内存

> vmstat、sar、top、pidstat等可以查看swap和物理内存的消耗情况。

网络

> - netstat
> - sar
> - tcpdump

- find
- grep
- chmod
- chown
- chgrp
- iostat
  - 查看各个设备的IO状态，查看磁盘读写性能)
- pidstat
  - 查看某个线程的IO状态)

运维

> - doc攻击
>
>   - https://www.zhihu.com/question/19581905
>
> - 反向代理是什么？
>
>   - 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器簇的存在.
>
> - 负载均衡是什么？
>
> - 
>
> - 非对称加密，对称加密
>
> - 
>
> - Http, Https 区别 (*)
>
>   - Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。
>
> - 长连接，短连接
>
>   - http://www.cnblogs.com/0201zcr/p/4694945.html
>
> - 三次握手，四次挥手(*)
>
> - 操作系统，临时抱佛脚
>
>   - https://blog.csdn.net/csdn_chai/article/details/78002202
>
>   - https://zhuanlan.zhihu.com/p/23755202
>
> - Linux 网络相关命令
>
>   - ping是使用的ICMP协议，是IP层协议，但是端口是应用层的，所以它只能判断能够访问ip，不能判断端口
>
>   - ifconfig是查看本机的网络设置，IP，子网掩码等
>
>   - telnet是应用层的，可以判端口访问情况
>
>   - netstat显示网络信息，如网络连接，路由表，接口状态
>
> - 查看linux操作系统磁盘空间命令
>
>   - df

#### 网络

> - 三次握手四次挥手
>
>   - 理解 TCP 协议中的 SYN 和 序列号 (seq) 非常重要，它们是实现可靠传输的核心机制。下面用更直观的方式解释它们：
>
>     1. SYN (Synchronize Sequence Number - 同步序列号)
>
>        - 是什么？ **SYN 是 TCP 报文段头部中的一个 控制标志位 (占 1 bit)。**
>
>        - 长啥样？ **在 TCP 头部中，有几个这样的标志位（如 URG、ACK、PSH、RST、SYN、FIN）。SYN 位本身就是一个开关：置为 1 表示“开启”，置为 0 表示“关闭”。**
>
>        - 干什么用？
>
>          - 建立连接： **当 SYN 位被置为 1 时，表示这个 TCP 报文段是用于 发起一个新连接请求 或 响应一个连接请求 的。**
>
>          - 同步序列号： **它的核心作用是告诉对方：“请将我携带的这个序列号 (seq) 作为我们之间通信的 起始点”。**
>
>        - 在哪出现？ SYN 标志位在 三次握手 的前两次报文中被置为 1：
>
>          - 第一次握手 (SYN)： **客户端发送 SYN=1, seq=x (x 是客户端的初始序列号)。**
>
>          - 第二次握手 (SYN + ACK)： **服务器回复 SYN=1, ACK=1, seq=y, ack=x+1 (y 是服务器的初始序列号，同时确认收到了客户端的 SYN)。**
>
>        - 简单理解： **SYN=1 的包就是大声喊：“嘿！我们开始通话吧！我的第一句话编号是 XXX！”**
>
>     2. 序列号 (Sequence Number - seq)
>
>     - 是什么？ seq 是 TCP 报文段头部中的一个 32 位 (4 字节) 的无符号整数字段。
>
>     - 长啥样？ 它就是一个数字！在抓包工具 (如 Wireshark) 或日志中，你通常会看到它被表示为一个 十进制整数 或 十六进制数。例如：
>
>       - seq=0
>
>       - seq=423905729 (一个随机的大数)
>
>       - seq=0x2cf8eef2 (十六进制表示)
>
>     - 干什么用？ 序列号是 TCP 实现 可靠、有序数据传输 的基石：
>
>       - 1. 标识字节流： 它标识了 本报文段所携带的应用层数据的第一个字节 在整个要传输的数据流中的位置（偏移量）。想象你要传输一个 10000 字节的文件，第一个包可能携带字节 0-999，seq=0；第二个包携带字节 1000-1999，seq=1000。
>
>       - 2. 保证有序： 接收方根据 seq 的大小将乱序到达的报文段重新排序，组装成正确的数据流交给应用层。
>
>       - 3. 检测丢失和重复： 接收方通过检查 seq 是否连续（或落在预期范围内），可以判断是否有数据包丢失或重复发送。
>
>       - 4. 确认机制基础： 接收方发送的 确认号 (ACK) 就是基于收到的 seq 计算出来的，它告诉发送方：“我已经成功收到了所有序号小于 ACK 的数据”。
>
>     - 初始序列号 (ISN - Initial Sequence Number)：
>
>       - 在建立连接的三次握手时，客户端和服务器各自会选择一个 随机数 作为自己发送方向的初始序列号 (就是第一次握手里的 x 和第二次握手里的 y)。
>
>       - 为什么随机？ 主要是为了安全（防止被猜测序列号进行攻击）和避免旧连接的报文被新连接误认（序列号空间复用）。
>
>     - 后续序列号：
>
>       - 握手完成后，发送数据的第一个报文段的 seq 就是 ISN + 1（因为 SYN 包本身消耗了一个序列号空间，即使它不携带应用数据）。
>
>       - 之后每个报文段的 seq = 上一个报文段的 seq + 上一个报文段中携带的应用层数据的字节数。
>
>       - 如果报文段不携带应用数据（如纯 ACK 包、FIN 包），它也会消耗一个序列号空间，下一个数据包的 seq 需要加 1。
>
>     - 简单理解： 序列号就像是给传输的每一个字节都编了一个唯一的号码。发送方说：“我这次发的是第 N 号字节开始的数据”。接收方收到后说：“我成功收到了第 N 号到第 M 号字节，下次请从第 M+1 号开始发”。
>
>   - 图解序列号在握手和数据传输中的变化
>
>     - 假设客户端 (C) 和服务器 (S) 建立连接并传输数据：
>
>     -  三次握手：
>
>       - C -> S: SYN=1, seq=100 (ISN_C=100) // C 说：开始通话！我的第一个字节编号是 100。
>
>       - S -> C: SYN=1, ACK=1, seq=500 (ISN_S=500), ack=101 // S 说：收到！同意开始！我的第一个字节编号是 500。我确认收到了你的 SYN (100)，期待你的下一个字节是 101。
>
>       - C -> S: ACK=1, seq=101, ack=501 // C 说：收到你的 SYN (500)！我确认收到了。我的下一个数据字节将从 101 开始。期待你的下一个字节是 501。
>
>     -  数据传输：
>
>       - C -> S: seq=101, len=100, data[...] // C 发送 100 字节数据 (字节 101-200)
>
>       - S -> C: ACK=1, ack=201 // S 确认：成功收到字节 101-200 (共100字节)，期待下一个字节 201。 (ack = 收到的最新 seq + len = 101 + 100 = 201)
>
>       - S -> C: seq=501, len=50, data[...] // S 发送 50 字节数据 (字节 501-550)
>
>       - C -> S: ACK=1, ack=551 // C 确认：成功收到字节 501-550 (共50字节)，期待下一个字节 551。 (ack = 501 + 50 = 551)
>
>     - 3. 四次挥手 (简化)：
>
>       - C -> S: FIN=1, seq=201 // C 数据发完了，要关闭发送通道。 (假设C在上次ACK后没再发数据，seq还是201)
>
>       - S -> C: ACK=1, ack=202 // S 确认收到了C的FIN (FIN消耗一个序号，所以确认下一个期待的字节是 201 + 1 = 202)
>
>       - S -> C: FIN=1, seq=551 // S 也发完了数据，要关闭发送通道。 (假设S在上次发数据后没再发，seq还是551)
>
>       - C -> S: ACK=1, ack=552 // C 确认收到了S的FIN (FIN消耗一个序号，所以确认下一个期待的字节是 551 + 1 = 552)
>
>   - 总结
>
>     - SYN： TCP 头部的一个标志位 (1 bit)。置 1 表示该报文用于发起或同意建立新连接，并携带初始序列号 (ISN)。
>
>     - 序列号 (seq)： TCP 头部的一个 32 位字段 (一个数字)。它标识了本报文段所携带数据的第一个字节在整个数据流中的位置。初始值是随机的 (ISN)，后续值根据已发送数据的长度递增。它是 TCP 实现可靠、有序传输的核心机制。
>
>     - 长啥样： 在现实中，你看到的就是一个数字 (如 423905729) 或十六进制数 (如 0x1942FE41)，代表当前传输的字节流的起始位置。
>
>     - 理解 SYN 和 seq 是理解 TCP 连接建立、数据传输和连接终止过程的关键！它们共同确保了数据在网络中能可靠、有序地从一端传递到另一端。
>
> - TCP UDP区别
>
>   - https://zhuanlan.zhihu.com/p/24860273
>
>   - TCP是面向连接的，UDP是无连接的；
>
>   - TCP是可靠的，UDP是不可靠的；
>
>   - TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；
>
>   - TCP是面向字节流的，UDP是面向报文的；
>
>   - TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；
>
>   - TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；
>
> - 网络层的ARP协议工作原理
>
>   - 网络层的ARP协议完成了IP地址与物理地址的映射。首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。
>
> - HTTP常见状态码
>
>   - 1×× : 请求处理中，请求已被接受，正在处理
>
>   - 2×× : 请求成功，请求被成功处理
>
>   - 200 OK
>
>   - 3×× : 重定向，要完成请求必须进行进一步处理
>
>   - 301 : 永久性转移
>
>   - 302 ：暂时性转移
>
>   - 304 ： 已缓存
>
>   - 4×× : 客户端错误，请求不合法
>
>   - 400：Bad Request,请求有语法问题
>
>   - 403：拒绝请求
>
>   - 404：客户端所访问的页面不存在
>
>   - 5×× : 服务器端错误，服务器不能处理合法请求
>
>   - 500 ：服务器内部错误
>
>   - 503 ： 服务不可用，稍等
>
> - HTTP协议是无状态的 和 Connection: keep-alive的区别
>
>   - HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。
>
>   - 从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
>
>   - Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间
>
> - 属于网络112.10.200.0/21的地址是? (*)
>
>   - 笔试常考
>
>   - 前21位为网络地址，后12位为主机地址。112 对应前8位，10对应第二个8位，因此200对应第3个8位又200的二进制表示为1100 1000 前面已经有了16位，因此11001 是属于网络地址的。000是属于主机地址那么，最大的地址为【112（十进制）】【10（十进制）】【11001  111】【11111111】转换为十进制为112.10.207.255 故网络的地址范围为: 112.10.200.0~112.10.207.255
>
> - 某一速率为100M的交换机有20个端口，其一个端口上连着一台笔记本电脑，此电脑从迅雷上下载一部1G的电影需要的时间可能是多久？
>
>   - 1GB/(100Mb/s ÷8,字节→比特)=81.92 s, 比81s大
>
>   - 交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。
>
> - 与10.110.12.29 mask 255.255.255.224属于同一网段的主机IP地址是?(*)
>
>   - 通俗理解：
>
>   - 子网掩码为255.255.255.224=255.255.255.11100000，也就是讲第四个字节，有三位用来表示子网号（共有000，001，010....111等8个子网号）
>
>   - 请看题目给的是：10.110.12.29=10.110.12.29=10.110.12.00011101，从这里看，题目给出的IP所处子网号在000段，所以跟这个IP在一个网段的IP的前27位是定的：10.110.12.000
>
>   - 最后5位可以是00001~11110（全0和全1是不行的），也就是讲IP范围为 10.110.12.000 00000~10.110.12.000 11110
>
> - 数据在计算机网络中的称法？
>
>   - 应用层：报文
>
>   - 运输层：报文段/用户数据报
>
>   - 网际层：IP数据报/分组/包
>
>   - 数据链路层：帧
>
>   - 物理层：比特流

- （1）计算机网络

  - OSI 七层模型、TCP/IP五层模型

  - 常见网络协议：HTTP、TCP/IP、UDP

  - 网络安全：非对称加密、数字签名、数字证书

  - 网络攻击：DDOS、XSS、CSRF 跨域攻击

- 书籍推荐

  - 《网络是怎么连接的》

  - 《图解 HTTP》

  - 《TCP/IP详解卷1：协议》

- （2）操作系统

  - 《深入理解计算机系统 CSAPP》

  - 《现代操作系统 （第3版）》

- 最全从输入URL到浏览器显示页面过程中都发生了什么？[前端浏览器渲染流程](https://zhuanlan.zhihu.com/p/476146523)



