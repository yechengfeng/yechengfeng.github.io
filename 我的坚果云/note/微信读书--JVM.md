- ### 运行时数据区域

  - <img src="https://leslieyedoc.oss-cn-shanghai.aliyuncs.com/img/20250909-130148-8209378_c81f2c56-6e7c-4b8a-dabd-f0342c6b1787-20250909130148383.png " style="zoom:25%;  float:left"/>

- ### 程序计数器 （线程私有）

  - 当前线程的字节码行号指示器 ，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。

- ### Java虚拟机栈（线程私有）

  - 与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stack)也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧[插图](Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

- ### 本地方法栈

  - 与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stack)也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧[插图](Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

- ### 堆

  - 线程本地缓存区（百分之1的空间，在eden区）

- ### 分代收集理论

  - ##### 弱分代假说
    
    - 绝大多数对象都是朝生夕灭
    
  - ##### 强分代假说
    
    - 熬过了越多次垃圾收集的对象越难消亡
    
  - 所以

    - 收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储

    - 所以才会有minnerGc ，MajorGC ，fullGC

    - 所以出现了标记-复制算法，标记-清除算法，标记-整理算法

  - 部分收集（Partial GC）
    - 新生代收集（Minor GC/young GC）

  - 老年代收集 Major GC/Old GC

  - 混合收集 fix GC

  - 整堆收集 full GC

- 标记清除算法

  - 如果大对象较多，回收效率低下，效率不稳定

  - 产生内存碎片

- 标记复制算法（年轻代）

  - 内存会缩小一半

  - Appel算法（大多数对象撑不过一轮GC，所以分为较大的eden区和俩快survivor区。默认Eden区和survivor区8:1,也就是大多数对象在第一轮GC就被回收了）如果没有放下，那么进入直接进入老年代

- 标记整理算法（老年代）