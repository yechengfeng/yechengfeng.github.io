> 在 Java 中，s1 == s2 返回 false 的原因与字符串常量池的工作机制以及 new String() 的行为有关。
>
> ### 1. 字符串创建方式的不同
>
> ```java
> String s1 = new String("a");
> ```
>
> **创建了两个对象（如果常量池没有 "a"）：**
>
> 1. 常量池对象：字面量 "a" 会先在字符串常量池中创建（如果池中不存在）
>
> 2. 堆java内存对象：new String() 会在堆内存中创建一个全新的字符串对象，内容与常量池中的 "a" 相同，但地址不同。
>
>    #### **s1 指向的是堆内存中的新对象，而非常量池对象**
>
> ```java
> String s2 = new String("a");
> ```
>
> ​	常量池已存在 "a"（由第一条语句创建），因此不再重复创建常量池对象。但 new String() 会再次在堆内存中创建另一个新对象。s2 指向这个新的堆内存对象。
>
> ### 2. == 运算符的作用
>
> 1. == 比较的是对象的引用地址（内存地址），不是内容。
> 2. s1 和 s2 指向的是堆内存中两个不同地址的对象：

### 总结

 1. new String("a")一定会创建新堆对象，无论常量池是否存在 "a"。

 2. 常量池仅存储字面量如"a"或通过.intern()方法显式加入的字符串。

 3. 如果想强制引用常量池中的对象，需使用.intern()：

 4. ```java
     	java String s1 = new String("a").intern(); // 返回常量池中的 "a" 
    	String s2 = new String("a").intern(); 
     	 同上 System.out.println(s1 == s2); // true（指向常量池同一对象） 
    ```

 5. 关于这个String 引发的生产问题

    	1.  比如用户前端传过来一个字符串，这个字符串是通过new String()的方式获取的，所以后端加锁的时候没有效果  ~.~