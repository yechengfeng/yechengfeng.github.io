### 多线程基础概念

- #### 1.关于多线程的一些概念

  - 同步(Synchronous)和异步(Asynchronous)
  -  并发 (Concurrency)和并行 (Parallelism)
  - 临界区
    - 临界区用来表示一种公共资源或者说共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源就必须等待
  - 阻 塞 (Blocking ) 和 非 阻 塞 ( Non-Blocking )
  - 死 锁 (D e a d l o c k ) 、 饥 饿 ( S t a r v a t i o n ) 和 活 锁 ( L i v e l o c k )
    - 饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行
    - 活锁是指主动将资源释放给他人使用，那么就会导致资源不断地在两 个线程间跳动，而没有一个线程可以同时拿到所有资源正常执行。这种情况就是。

- #### 2.并发级别

  - 并发级别 由于临界区的存在，多线程之间的并发必须受到控制。根据控制并发的策略，我们可 以把并发的级别分为阻塞、无饥饿、无障碍、无锁、无等待几种。

- ### 3.并行的俩个定律

  - Amdahl定律 阿姆达尔定律
    - Amdahl 定律是计算机科学中非常重要的定律。它定义了串行系统并行化后的加速比的 计算公式和理论上限。加速比越高，优化越明显
      - 加速比 = 优化前系统耗时 / 优化后系统耗时
  - Gustafson定律
    - 如果可被并行化的代码所占比例足够大，那么加速比就能随着CPU的数量线性增长

- JMM(java内存模型)

  - 原子性 (Atomicity)
  - 可见性(Visibility)
  - 有 序 性 (Ordering )

### 多线程编程需要注意的问题

##### 1. 线程安全问题

 1. ##### 原子性

     1. 在并发编程中很多操作都不是原子操作
        
        ```java
        	1. i = 0;  //对基本数据类型变量的赋值是原子操作；
        	2. i++; // 包含三个操作，读取i的值，将i加1，将值赋给i；
        	3. i = j; // 读取j的值，将j的值赋给i；
        	4. i = i + 1; //操作4：包含三个操作，读取i的值，将i加1，将值赋给i；
        ```
        
        

 2. ##### 可见性

    - 指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

 3. ##### 有序性

##### 2. 活跃性问题

> 活跃性是指某件正确的事情最终会发生，当某个操作无法继续下去的时候，就会发生活跃性问题。

- 死锁

  > 死锁是指多个线程因为环形的等待锁的关系而永远的阻塞下去。一图胜千语，不多解释。

- 活锁

  > 死锁是两个线程都在等待对方释放锁导致阻塞。而活锁的意思是线程没有阻塞，还活着呢。

- 饥饿

  > 如果一个线程无其他异常却迟迟不能继续运行，那基本是处于饥饿状态了。

##### 3. 性能问题

- CPU是很宝贵的资源速度也非常快，为了保证雨露均沾，通常为给不同的线程分配时间片，当CPU从执行一个线程切换到执行另一个线程时，CPU 需要保存当前线程的本地数据，程序指针等状态，并加载下一个要执行的线程的本地数据，程序指针等，这个开关被称为『上下文切换』。（上下文切换在现代计算机中其实时间很短，几微秒而已）
- 一般减少上下文切换的方法有：无锁并发编程、CAS 算法、使用协程等。

##### 总结

<img src="https://leslieyedoc.oss-cn-shanghai.aliyuncs.com/img/20250909-205117-image-20250909205110679.png" alt="image-20250909205110679" style="zoom:50%;" />



##### 4. 死锁产生的条件

- **互斥条件**：一个资源每次只能被一个进程使用。
- **占有且等待**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- **不可强行占有**:进程已获得的资源，在末使用完之前，不能强行剥夺。
- **循环等待条件**:若干进程之间形成一种头尾相接的循环等待资源关系。

##### 5. 避免死锁[https://segmentfault.com/a/1190000000378725](https://segmentfault.com/a/1190000000378725)

- 确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生.

- 另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。

- 死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。

###### 6. 公平锁、非公平锁

- 公平锁（Fair）：加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得

-  非公平锁（Nonfair）：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待非公平锁性能比公平锁高5~10倍，因为公平锁需要在多核的情况下维护一个队列Java中的ReentrantLock 默认的lock()方法采用的是非公平锁。







