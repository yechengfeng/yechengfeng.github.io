> - ### 缓存一致性问题
>
>   - 三种缓存策略：**Cache Aside 策略**、**Read/Write Through 策略**、**Write Back 策略**
>     - https://bbs.huaweicloud.com/blogs/365239（推荐）
>
>   - 主要用到的还是Cache Aside策略
>
>     - 读请求
>       - <img src="https://leslieyedoc.oss-cn-shanghai.aliyuncs.com/img/20250909-154523-8209378_6e95d117-32a1-46f3-f779-9fe27cab94a2.png" alt="img" style="zoom:100%; float:left" />
>
>     - 写请求
>
>       - 先更新数据库，然后删除缓存
>         - 踩坑
>           1. 先更新数据库，然后更新缓存，
>              - 如果同时有俩个写请求，就可能发生缓存不一致问题
>           2. 先删缓存，再更新数据库
>              - 在一个读请求和一个写请求并发场景下可能会出现数据不一致情况。
>
>       - 但是先更新数据库，再删除缓存，还是可能有问题
>
> - ### 电商平台Redis分布式锁导致的超卖问题
>
>   - 原因是由于网络抖动，导致redis的锁失效了
>
>   - 生产代码
>     - <img src="https://leslieyedoc.oss-cn-shanghai.aliyuncs.com/img/20250909-154745-8209378_868a5f23-f7ee-4f80-c512-0581d6052982.png" alt="img" style="zoom:200%;" />
>
>   - ### 分析
>
>     - 没有其他系统风险容错处理由于用户服务吃紧，网关响应延迟，但没有任何应对方式，这是超卖的导火索。
>
>     - 看似安全的分布式锁其实一点都不安全虽然采用了set key value [EX seconds] [PX milliseconds] [NX|XX]的方式，但是如果线程A执行的时间较长没有来得及释放，锁就过期了，此时线程B是可以获取到锁的。当线程A执行完成之后，释放锁，实际上就把线程B的锁释放掉了。这个时候，线程C又是可以获取到锁的，而此时如果线程B执行完释放锁实际上就是释放的线程C设置的锁。这是超卖的直接原因。
>
>     - 非原子性的库存校验非原子性的库存校验导致在并发场景下，库存校验的结果不准确。这是超卖的根本原因。
>
>   - ### 解决
>
>     - 利用lua脚本来保证加锁释放锁是同一把锁
>
>   - ### 分布式锁的选型
>
>     - 有人提出用RedLock来实现分布式锁。RedLock的可靠性更高，但其代价是牺牲一定的性能。在本场景，这点可靠性的提升远不如性能的提升带来的性价比高。如果对于可靠性极高要求的场景，则可以采用RedLock来实现。