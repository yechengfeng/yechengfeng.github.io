> - **全局锁**
>
>   - flush tables with read lock
>
>     - 执行后，整个数据库就处于只读状态了，这时其他线程执行以下操作，都会被阻塞：
>
>       - 对数据的增删改操作，比如 insert、delete、update等语句；
>
>       - 对表结构的更改操作，比如 alter table、drop table 等语句。
>
>   - unlock tables 释放
>
>   - 当会话断开了，全局锁会被自动释放。
>
>   - 既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？
>     - 当数据库支持可重复读的隔离级别，那么备份数据库之前可以开启事务，会创建read view，由于MVCC的支持，备份期间业务依然可以对数据进行update。备份数据库的工具是 mysqldump，备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 –single-transaction。 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。
>
> - **表级锁**
>
>   - 表锁；
>
>     - lock tables t_student read; 表级别的共享锁，读锁
>       - 允许当前会话读取被锁定的表，阻止其他会话对表进行写操作
>
>     - lock tables  t_student  write;//表级别的独占锁，也就是写锁；
>       - //允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）。
>
>     - unlock tables
>
>   - 元数据锁 (MDL)
>
>     - 不需要显示声明，对数据库进行操作，会自动给表加上锁，MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。
>
>       - 对一张表进行crud时候，会自动加上读锁
>         - 当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。
>
>       - 对一张表结构变更时候，会自动加上写锁
>
>     - MDL 不需要显示调用，那它是在什么时候释放的?
>
>       - MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。
>
>         - 那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：
>
>           - 1.首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；
>
>           - 2.然后，线程 B 也执行了同样的 select  语句，此时并不会阻塞，因为「读读」并不冲突；
>
>           - \3. 接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，
>
>           - 那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。
>
>         - 为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？
>
>           - 这是因为申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。
>
>           - 所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。
>
>   - **意向锁**；
>     - 意向锁的目的是为了快速判断表里是否有记录被加锁。
>
>   -  **AUTO-INCE锁；**
>
>     - 表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 AUTO-INC 锁实现的。
>
>     - AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放，但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增。
>
> - **行级锁**
>
>   - InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。