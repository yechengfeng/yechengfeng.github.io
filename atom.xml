<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yechengfeng.github.io</id>
    <title>Gridea</title>
    <updated>2021-11-15T01:24:33.551Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yechengfeng.github.io"/>
    <link rel="self" href="https://yechengfeng.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://yechengfeng.github.io/images/avatar.png</logo>
    <icon>https://yechengfeng.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[二叉树]]></title>
        <id>https://yechengfeng.github.io/post/er-cha-shu/</id>
        <link href="https://yechengfeng.github.io/post/er-cha-shu/">
        </link>
        <updated>2021-11-13T09:52:58.000Z</updated>
        <content type="html"><![CDATA[<h5 id="二叉树的诞生">二叉树的诞生</h5>
<pre><code>有序数组的查找速度很快， 插入删除相对较慢。
链表的插入和删除速度非常快。但是查找的速度很慢。
二叉树结合了数组与链表结构的优点，成为了更加快速的高级数据结构。（也可以说二叉树结合了俩者的缺点，查找速度比不过有序数组，插入删除比不过链表~~~~）
</code></pre>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/BST.html">二叉树体验网站</a></p>
<figure data-type="image" tabindex="1"><img src="https://yechengfeng.github.io/post-images/1636797978956.png" alt="asd" loading="lazy"></figure>
<p>参考文章<br>
<a href="https://www.jianshu.com/p/bf73c8d50dc2">深入学习二叉树(一) 二叉树基础</a><br>
<a href="https://zhuanlan.zhihu.com/p/136758152">万字长文！二叉树入门和刷题看这篇就够了！</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PriorityQueue]]></title>
        <id>https://yechengfeng.github.io/post/priorityqueue/</id>
        <link href="https://yechengfeng.github.io/post/priorityqueue/">
        </link>
        <updated>2021-11-13T09:32:41.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/CarpenterLee/p/5488070.html">深入理解Java PriorityQueue</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AbstractColletion]]></title>
        <id>https://yechengfeng.github.io/post/abstractcolletion/</id>
        <link href="https://yechengfeng.github.io/post/abstractcolletion/">
        </link>
        <updated>2021-11-13T09:19:11.000Z</updated>
        <content type="html"><![CDATA[<p><strong>此类提供集合接口的框架实现。<br>
为了实现一个不可修改的集合，程序员只需要扩展这个类并提供迭代器和size方法的实现。（迭代器方法返回的迭代器必须实现hasNext和next。）</strong></p>
<pre><code class="language-java">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {
  	
	    protected AbstractCollection()
        
}
</code></pre>
<ol>
<li>
<p>迭代器</p>
<pre><code class="language-java">//迭代器    
public abstract Iterator&lt;E&gt; iterator();

</code></pre>
</li>
<li>
<pre><code class="language-java">//抽象方法，子类实现
public abstract int size();
</code></pre>
</li>
<li>
<pre><code class="language-java">//依赖 size方法
public boolean isEmpty() {
        return size() == 0;
    }	
</code></pre>
</li>
<li>
<p>判断集合是否为空</p>
<pre><code class="language-java">public boolean contains(Object o) {
    Iterator&lt;E&gt; it = iterator();
  
    if (o == null) { 
        while (it.hasNext()) 
            if (it.next() == null)
                return true;
    } else {
        while (it.hasNext()) 
            if (o.equals(it.next()))
                return true;
    }
    return false;
}

</code></pre>
<blockquote>
<p>判断集合是否包含某个元素，有可能抛出ClassCastException、NullPointerException异常。<br>
此方法是通过使用迭代器遍历集合的每一个元素，然后使用equals()方法分别判断它们是否与指定对象相等来实现的。因为Iterator的存在，这里才可以进行一致性封装，使得此方法适用于各种类型的集合。同时，也要注意到对象的比较是通过equals()方法，而且还调用了it.next()、it.hasNext()方法，这也是为什么实现集合类需要重写equals()方法以及Iterator的两个方法。</p>
</blockquote>
</li>
<li>
<p>返回一个包含所有元素的数组</p>
<pre><code class="language-java">public Object[] toArray() {
        // Estimate size of array; be prepared to see more or fewer elements
        //先根据当前集合大小声明一个数组
        Object[] r = new Object[size()];
        Iterator&lt;E&gt; it = iterator();
        for (int i = 0; i &lt; r.length; i++) {
            //集合元素没有这么多，说明不需要那么大的数组
            if (! it.hasNext()) // fewer elements than expected
                return Arrays.copyOf(r, i); //仅返回赋完值的部分
            r[i] = it.next();
        }
        //元素比从size()中获取的更多，就需要进一步调整数组大小
        return it.hasNext() ? finishToArray(r, it) : r; 
    }
</code></pre>
<blockquote>
<ol>
<li>先创建一个同样大小的Object数组对象。</li>
<li>对于线程并发的时候，改变了集合元素的个数。需要调整返回数组的大小。保证数据的一致性。但是此举不能解决线程安全问题。</li>
</ol>
</blockquote>
</li>
<li>
<p>finishToArray</p>
<pre><code class="language-java">//当迭代器返回的元素比预期的多，并从迭代器中完成填充。
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
private static &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) {
        int i = r.length;
        while (it.hasNext()) {
            int cap = r.length;
            if (i == cap) {
                int newCap = cap + (cap &gt;&gt; 1) + 1;
                // overflow-conscious code
                if (newCap - MAX_ARRAY_SIZE &gt; 0)
                    newCap = hugeCapacity(cap + 1);
                r = Arrays.copyOf(r, newCap);
            }
            r[i++] = (T)it.next();
        }
        // trim if overallocated
        return (i == r.length) ? r : Arrays.copyOf(r, i);
    }
</code></pre>
</li>
<li>
<pre><code class="language-java">//默认抛出异常
public boolean add(E e) {
        throw new UnsupportedOperationException();
    }
</code></pre>
</li>
<li>
<pre><code class="language-shell"> //其他方法。
  boolean remove(Object o);
	boolean containsAll(Collection&lt;?&gt; c);
	boolean addAll(Collection&lt;? extends E&gt; c);
	boolean removeAll(Collection&lt;?&gt; c);
boolean retainAll(Collection&lt;?&gt; c);
void clear();
boolean equals(Object o);
	int hashCode();
</code></pre>
</li>
</ol>
<h3 id="参考">参考</h3>
<ul>
<li><a href="https://codeleading.com/article/29613289339/">Thinking in java 读书笔记</a></li>
<li><a href="https://codeleading.com/article/19601713701/">AbstractCollection</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于争论]]></title>
        <id>https://yechengfeng.github.io/post/guan-yu-zheng-lun/</id>
        <link href="https://yechengfeng.github.io/post/guan-yu-zheng-lun/">
        </link>
        <updated>2021-11-07T15:04:27.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p><strong>有俩个贵族想争论一下谁知道的数字更大，一个苦思冥想了半天，说出了一个数字三，另一个想了半天，实在想不出来，于是认输了，觉得三就是世界上最大的数字。</strong></p>
<!-- more -->
<p><em>往往我们和别人争辩的时候就变成了这俩个贵族。有时候即使争辩赢了，也不一定是对的。甚至，更多的时候，大家都是小丑而已。不如寻找问题的解决方法</em></p>
<!-- more -->
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mac 命令行工具]]></title>
        <id>https://yechengfeng.github.io/post/mac-ming-ling-xing-gong-ju/</id>
        <link href="https://yechengfeng.github.io/post/mac-ming-ling-xing-gong-ju/">
        </link>
        <updated>2021-11-07T14:00:57.000Z</updated>
        <content type="html"><![CDATA[<h3 id="autojump">autojump</h3>
<p><strong>进行目录跳转</strong></p>
<h3 id="csvkit">csvkit</h3>
<p><strong>csvkit 处理csv的瑞士军刀，做爬虫时候用curl命令 + jq  +csvkit 来处理一些网页接口的数据，直接得到可交付的excel。</strong></p>
<h3 id="jq"><a href="https://stedolan.github.io/jq/">jq</a></h3>
<p>官网介绍： <code>jq is like sed for JSON data - you can use it to slice and filter and map and transform structured data with the same ease that sed, awk, grep and friends let you play with text.</code><br>
<strong>我通常配合csvkit用来快速处理excel看文件，类似 sed，awk，grep一样的文本处理工具。</strong></p>
<h3 id="mycli">mycli</h3>
<p><strong>mysql命令行工具。轻便的mysql数据查询工具</strong></p>
<h3 id="sips">sips</h3>
<p><strong>我通常用来处理图片的大小，图片格式转换。其他强大功能没做过研究</strong></p>
<h3 id="translate"><a href="https://github.com/soimort/translate-shell">translate</a></h3>
<p>**终端翻译软件。google 出品 **</p>
<pre><code class="language-shell"># 终端shell配置文件中配置一下ts 函数
function ts(){
     trans -b :zh &quot;$*&quot;
  trans -b :en &quot;$*&quot;
}
#然后需要翻译
$ts hello  
</code></pre>
<h3 id="tig">tig</h3>
<p>git的升级命令，经常用来查询提交树。感觉比<code>sourtree</code>小巧。所以 选择他</p>
<h3 id=""></h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mac装机软件]]></title>
        <id>https://yechengfeng.github.io/post/mac-zhuang-ji-ruan-jian/</id>
        <link href="https://yechengfeng.github.io/post/mac-zhuang-ji-ruan-jian/">
        </link>
        <updated>2021-11-07T11:48:25.000Z</updated>
        <content type="html"><![CDATA[<p><strong>介绍自己mac装机必备图形软件。下次再换机的时候可以很方便的下载</strong></p>
<h6 id="item2"><a href="https://iterm2.com/features.html">item2</a>   <strong>推荐指数</strong>  ❤️❤️❤️❤️</h6>
<blockquote>
<p>比自带的item终端可扩展性可配置性更好，快捷操作更方便。可以配合<code>oh-my-zsh</code>定制自己个性化更方便的终端。具体查看<a href="https://iterm2.com/features.html">item2官网</a></p>
</blockquote>
<h5 id="securecrt"><a href="https://www.vandyke.com/products/securecrt/">SecureCRT</a>  <strong>推荐指数</strong>  ❤️❤️❤️❤️</h5>
<blockquote>
<p>一个Telnet 和ssh 会话的客户端工具。通常我用来管理多台linux服务器的session会话。不需要输入密码直接登录已经输入过密码的服务器。通常也可以在服务器上配置ssh 验证，通过 authorized_keys来让服务器记住密码达到同样的效果。或者通过 <code>expect</code> <code>spawn</code>写shell脚本自动登录的方式。(item2也可以配合脚本管理多个linux session会话。具体可以官网查看具体方法)。</p>
</blockquote>
<h5 id="microsoft-remote-desktop-推荐指数-️️️">Microsoft Remote Desktop      <strong>推荐指数</strong> <strong>❤️❤️❤️</strong></h5>
<blockquote>
<p>微软出的一个登录windows的客户端。很方便，可以创建session共享文件夹，和远程windows交换文件。</p>
</blockquote>
<h5 id="向日葵远程控制-推荐指数-️️️">向日葵远程控制     <strong>推荐指数</strong> <strong>❤️❤️❤️</strong></h5>
<blockquote>
<p>远程工具。主观感觉比teamview 好用一点。但是有一次，不明原因的在我本地家目录写入了70多个g的日志文件。直接给我磁盘干满了，本地写任务全部失败........ 后来google了一下，也有人和我产生了一样的问题。☠️，删掉日志就好。只遇到过一次。</p>
</blockquote>
<h5 id="蒲公英-推荐指数-️️️">蒲公英 <strong>推荐指数</strong> <strong>❤️❤️❤️</strong></h5>
<blockquote>
<p>内网穿透的工具。截至目前为止，提供三个免费的账号使用，正好保证了我的手机，电脑，家里的linux服务器。在公司也能访问到家里的服务器。</p>
</blockquote>
<h5 id="alfred4"><a href="https://www.alfredapp.com/">Alfred4</a> <strong>推荐指数</strong> <strong>❤️❤️❤️❤️</strong></h5>
<blockquote>
<p>聚焦搜索的加强版本。还可以配置workflows。是强烈推荐的一款应用。具体可以看官网或者其他系列教程。</p>
</blockquote>
<h5 id="itext"><a href="https://apps.apple.com/cn/app/itext/id1314980676?mt=12">iText</a> <strong>推荐指数</strong> <strong>❤️❤️❤️❤️</strong></h5>
<blockquote>
<p>ocr文字并且提取图片上面的文字。对于不方便复制的文字，有很好的效果。</p>
</blockquote>
<h5 id="bluefruit-connect-推荐指数-️">[Bluefruit Connect] <strong>推荐指数</strong> ❤️</h5>
<blockquote>
<p>我的hhkb键盘换了蓝牙主控之后，第一次搜索不到这个蓝牙模块。可以通过这个软件查找到搜索不到的蓝牙模块。快速连接。上次换机想安装这个软件，找了半天不知道叫啥名字☠️</p>
</blockquote>
<h5 id="clashx"><a href="https://github.com/yichengchen/clashX">clashx</a>  <strong>推荐指数</strong> ❤️❤️❤️</h5>
<blockquote>
<p>科学上网</p>
</blockquote>
<h5 id="snipaste-推荐指数-️️️️">Snipaste <strong>推荐指数</strong> ❤️❤️❤️❤️</h5>
<blockquote>
<p>截图软件，几乎人人都用，人人都说好的必备软件。比mac自带的好用。</p>
</blockquote>
<h5 id="colorsnapper2-推荐指数-️️️️">ColorSnapper2  <strong>推荐指数</strong> ❤️❤️❤️❤️</h5>
<blockquote>
<p>颜色提取器。还可以记住提取的历史。试了多个颜色提取的app，发现这个是我最满意的。</p>
</blockquote>
<h5 id="bob"><a href="https://github.com/ripperhe/Bob">Bob</a><strong>推荐指数</strong> ❤️❤️❤️❤️</h5>
<blockquote>
<p>每天都会用的翻译软件。小巧玲珑。大道至简。可以输入翻译，截图翻译，点击翻译。读音。最喜欢的翻译软件，配置自己的google翻译账号，或者百度翻译账号。每个月都有免费额度。基本用不完。调用百度或者google接口翻译。</p>
</blockquote>
<h5 id="typora-推荐指数-️️️️">Typora  <strong>推荐指数</strong> ❤️❤️❤️❤️</h5>
<blockquote>
<p>markdown 软件</p>
</blockquote>
<h5 id="things软件-推荐指数-️️️️">Things软件。   <strong>推荐指数</strong> ❤️❤️❤️❤️</h5>
<blockquote>
<p>日程安排。我用来记录会议纪要，快速记录自己的idea，记录日程和管理。对比了 类似app<code>SideNotes</code>，还是更喜欢Things。大巧不工的感觉。</p>
</blockquote>
<p>#####其他的开发软件就先不谈了 ,一笔带过</p>
<ul>
<li>idea ， PyCharm ，  vscode  (开发)</li>
<li>Anki 背单词。好久不用了</li>
<li>CheatSheet 快捷键提示</li>
<li>DBeaver， Dbkola  ，RDM(mysql ,mongodb ，redis 数据库链接)</li>
<li>goPanel 2 运维管理。方便linux session会话，和服务管理。</li>
<li>PDF Reader Pro， Wps Office</li>
<li>Postman 以前用，现在被google插件代替了。</li>
<li>Google Chrome 必备 不说了</li>
<li>Keka 解压缩。没找到啥比较好的解压缩应用，就用这个了，也还行。</li>
<li>Dash api文档浏览。方便查看。可以配置 到 afred，和其他的应用。其他mac用户的高频应。但是我用的不多。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux输入命令实用技巧]]></title>
        <id>https://yechengfeng.github.io/post/linux-shu-ru-ming-ling-shi-yong-ji-qiao/</id>
        <link href="https://yechengfeng.github.io/post/linux-shu-ru-ming-ling-shi-yong-ji-qiao/">
        </link>
        <updated>2021-11-06T05:45:51.000Z</updated>
        <summary type="html"><![CDATA[<h5 id="linux输入命令实用技巧">linux输入命令实用技巧</h5>
]]></summary>
        <content type="html"><![CDATA[<h5 id="linux输入命令实用技巧">linux输入命令实用技巧</h5>
<!-- more -->
<!-- more -->
<ul>
<li>
<p>​	<code>!$</code></p>
<pre><code>  $mkdir helloDir
  $mv helloDir helloworldDir
  $cd helloworldDir
</code></pre>
<blockquote>
<p>当你想要上述方式重复你自己的时候不妨试试 <code>!$</code></p>
</blockquote>
<pre><code>  $mkdir  helloDir
  $mv !$ helloworldDir
  $cd !$
</code></pre>
</li>
<li>
<p><code>sudo !!</code></p>
<blockquote>
<p>当你忘记加sudo的时候，可以试试 <code>sudo!!</code> (<code>Sudo !-1</code>  也可以)</p>
</blockquote>
</li>
<li>
<p><code>cd -</code></p>
<blockquote>
<p>当你想要切换到上个目录的时候。（this very userful, 在 zsh中，可以 cd -3，cd -4，cd -5 ,进行多个目录的切换。有点autojump的味道）</p>
</blockquote>
</li>
<li>
<p><code>&lt;ESC&gt; .</code></p>
<blockquote>
<p>Pick up the params from last command。上一个命令行的参数给获取出来。</p>
</blockquote>
</li>
<li>
<p><code>^ord^new</code></p>
<blockquote>
<p>替换上次命令中的部分字符串</p>
</blockquote>
</li>
<li>
<p><code>&gt; file.list</code></p>
<blockquote>
<p>代替touch 命令创建文件。</p>
</blockquote>
</li>
<li>
<p><code>&lt;ctrl&gt; u ,&lt;ctrl&gt; w,&lt;ctrl&gt; h</code></p>
<blockquote>
<p>删除整行命令，删除前一个单词，删除前一个字母。在linux中普遍适用的命令，vim中可以在 insert 模式删除，不需要回到normal 模式</p>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux中任务管理---命令 (jobs fg bg  ctrl-Z 命令 )]]></title>
        <id>https://yechengfeng.github.io/post/linux-zhong-ren-wu-guan-li-ming-ling-jobs-fg-bg-ctrl-z-ming-ling/</id>
        <link href="https://yechengfeng.github.io/post/linux-zhong-ren-wu-guan-li-ming-ling-jobs-fg-bg-ctrl-z-ming-ling/">
        </link>
        <updated>2021-11-01T16:28:30.000Z</updated>
        <content type="html"><![CDATA[<h3 id="ctrl-z">ctrl-z</h3>
<p>可以挂起当前正在前台执行的命令。放到后台暂停</p>
<h3 id="bg">bg</h3>
<ol>
<li>将最近在后台挂起的命令，变成继续执行。</li>
<li>可以 加上参数 % +id (指定具体的任务)</li>
</ol>
<h3 id="fg">fg</h3>
<ol>
<li>将最近一次后台的命令调至前台继续执行</li>
<li>可以 加上参数 % +id (指定具体的任务)</li>
</ol>
<h3 id="jobs">jobs</h3>
<p>查看当前有多少个正在后台运行的命令</p>
<p><em>这些命令很有用，具体的用法可以查看  man手册</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[queue]]></title>
        <id>https://yechengfeng.github.io/post/queue/</id>
        <link href="https://yechengfeng.github.io/post/queue/">
        </link>
        <updated>2020-11-13T09:33:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="queue">queue</h3>
<p>官网介绍</p>
<pre><code class="language-java">
public interface Queue&lt;E&gt; extends Collection&lt;E&gt; {}

/*相关类*/
Collection,
LinkedList, 
PriorityQueue,
java.util.concurrent.LinkedBlockingQueue, java.util.concurrent.BlockingQueue,
java.util.concurrent.ArrayBlockingQueue, java.util.concurrent.LinkedBlockingQueue, java.util.concurrent.PriorityBlockingQueue

</code></pre>
<h5 id="introduction">introduction</h5>
<ol>
<li>
<p>元素被处理前用来保存元素的集合。 除了基本的收集操作外，队列还提供附加的插入、提取和检查操作。</p>
</li>
<li>
<p>这些方法都有两种形式：一种是在操作失败时抛出异常，另一种是返回特殊值（null或false，具体取决于操作）。</p>
</li>
<li>
<p>插入操作的后一种形式专门设计用于容量受限的队列实现；在大多数实现中，插入操作不会失败。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>Throws exception</th>
<th>Returns special value</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Insert</td>
<td>add(e)</td>
<td>offer(e)</td>
<td></td>
</tr>
<tr>
<td>Remove</td>
<td>remove()</td>
<td>poll()</td>
<td></td>
</tr>
<tr>
<td>Examine</td>
<td>element()</td>
<td>peek()</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code>队列通常（但不一定）以FIFO（先进先出）的方式对元素进行排序。例外情况包括优先级队列（根据提供的比较器或元素的自然顺序对元素排序）和后进先出（后进先出）队列（或堆栈）。无论使用何种顺序，队列的头部都是通过调用remove（）或poll（）删除的元素。在FIFO队列中，所有新元素都插入到队列的尾部。其他类型的队列可能使用不同的放置规则。每个队列实现都必须指定其排序属性。
</code></pre>
<blockquote>
<p>想法：</p>
<p>发现 Queue 接口继承了 Collection接口，Collection 声明了add(),remove()方法，但是在queue中被再次声明。我觉得是因为：一方面是声明一个接口的时候需要保证核心功能的完整性 。接口和接口之间解耦合。比如Queue如果不是一个Colletions，不继承 collections,那么它定义的接口应该保证queue本身的功能完备。<br>
另一方面可能是显式告知使用者该方法在当前上下文和父接口上下文中使用方式和含义的差别。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BlockingQueue]]></title>
        <id>https://yechengfeng.github.io/post/blockingqueue/</id>
        <link href="https://yechengfeng.github.io/post/blockingqueue/">
        </link>
        <updated>2020-11-13T09:29:02.000Z</updated>
        <content type="html"><![CDATA[<p><strong>阻塞队列</strong></p>
<pre><code class="language-java">
public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; {

}

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://yechengfeng.github.io/post-images/1636795836461.png" alt="" loading="lazy"></figure>
<blockquote>
<p>比queue方法多了四个方法。</p>
</blockquote>
<blockquote>
<ol>
<li>ArrayBlockingQueue阻塞采用 ReentrantLock，Condition来实现。ReentrantLock本身 具有公平和非公平策略。 ArrayBlockingQueue中也保留了ReentrantLock这种特性。数据具有公平非公平的访问区别。是一个 ReentrantLock，Condition机制很好的实现。</li>
<li></li>
</ol>
</blockquote>
<p><a href="https://juejin.cn/post/6844903989788540941">ArrayBlockingQueue源码分析</a></p>
<p><a href="https://www.cnblogs.com/leesf456/p/5539071.html">LinkedBlokingQueue源码分析</a></p>
]]></content>
    </entry>
</feed>